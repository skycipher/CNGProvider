//#  (c) 2009 CodePlex Foundation
//#
//#  Title:                  Microsoft-Windows-usbport.events
//#
//#  Details:                
//#
//#  Public References:      usbport.events.man
//#
//#  Comments:               
//#
//#  Revision Class and Date:Minor, 07/15/2010
//#
//####

const IRP_MJ_DEVICE_CONTROL = 0xe;
const IRP_MJ_INTERNAL_DEVICE_CONTROL = 0xf;


[RegisterBefore(NetEvent.UserData, USBPort, "{c88a4ef5-d048-4013-9408-e04b7db2814a}")]
[RegisterBefore(NetEvent.UserData, USBHub, "{7426a56b-e2d5-4b30-bdef-b31815c1a74a}")]
Protocol USB = Property.ETLSummary
{
	// Properties
	// "USB Summary" property is an alias of "ETL Summary", and will be visible
	// to anyone searching for USB-related columns in the column chooser
	[Post.Property.USBSummary = Property.ETLSummary]
	[Post.Property.USBPortPath = IsValueNone(UsbPortPath.ToString) ? "-" : UsbPortPath.ToString]
	// USB Error Events, Hub Exceptions, or URB Errors
	[Post.Property.USBIsError =
		((
			(USBPort AND NetEvent.Header.Descriptor.Opcode == 34) 
			OR
			(USBHub AND NetEvent.Header.Descriptor.Opcode == 11) 
			OR
			(NetEvent.Header.Descriptor.Level == 0x2) 
			OR
			(USBHub AND NetEvent.Header.Descriptor.Id == 210)
			OR
			(Property.USBDStatus != "success" && Property.USBDStatus != "" && Property.USBDStatus != "canceled")
			OR
			(Property.USBNtStatus != "success" && Property.USBNtStatus != "" && Property.USBNtStatus != "0xC0000120 - STATUS_CANCELLED")
		) ? 1 : 0)]

	// Conversations
	// First level of tree: a node for each host controller
	// Key it to the HC identifier string
	[Post.ProxyBuildConversationWithParent("USB", USBPort_HostController.ToString)]
	// Compact host controller string. Gets data from the HC conversation.
	[Post.Property.USBHostController = FormatString("%x-%x%s", USBPort_HostController.PciDevice, USBPort_HostController.PciFunction, Conversation.USBIsEhci ? " e" : "")]
	// Name of host controller node
	// Due to the Protocol name of "USB", "Controller" becomes "USB Controller" as intended.
	[Post.Conversation.ConversationDescription =
		FormatString("Controller: (%s) PCI bus %d, device %d, function %d%s",
		Property.USBHostController,
		USBPort_HostController.PciBus, USBPort_HostController.PciDevice, USBPort_HostController.PciFunction, Conversation.USBIsEhci ? " (EHCI)" : ""
		)]
	// Proxy to UsbPort in case this is a UsbHub event
	[Post.ProxyBuildConversationWithParent("UsbPort", Property.USBPortPath)]
	[Post.Conversation.EventCount = ((IsValueNone(Conversation.EventCount) ? 0 : Conversation.EventCount) + 1)]
	[Post.Conversation.ErrorCount = ((IsValueNone(Conversation.ErrorCount) ? 0 : Conversation.ErrorCount) + Property.USBIsError)]
	// Name of port path node
	// Due to protocol name of "USBPort", this will read "USBPort Path: ..."
	[Post.Conversation.ConversationDescription = (FormatString("%s (Events: %d, Errors: %d)", (IsValueNone(Property.USBPortPath) ? "-" : FormatString("Path: %s", Property.USBPortPath)), Conversation.EventCount, Conversation.ErrorCount))]

	switch(Property.ETLProviderGUID)
	{
		case "{c88a4ef5-d048-4013-9408-e04b7db2814a}": USBPort UsbPort;
		case "{7426a56b-e2d5-4b30-bdef-b31815c1a74a}": USBHub UsbHub;
	}
}

Protocol USBPort = property.ETLSummary
{
	//
	// All URBs logged by Usbport *do not* include NTSTATUS
	//
	[Property.InternalUsbNtstatusUrbs = 0]
	switch(property.EventID)
	{
		case 1: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_ADD USBPORT_ETW_EVENT_HC_ADD;
		case 2: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_REMOVAL USBPORT_ETW_EVENT_HC_REMOVAL;
		case 3: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_INFORMATION USBPORT_ETW_EVENT_HC_INFORMATION;
		case 4: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_START USBPORT_ETW_EVENT_HC_START;
		case 5: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_STOP USBPORT_ETW_EVENT_HC_STOP;
		case 6: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_SUSPEND USBPORT_ETW_EVENT_HC_SUSPEND;
		case 7: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_RESUME USBPORT_ETW_EVENT_HC_RESUME;
		case 8: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_ASYNC_SCHEDULE_ENABLE USBPORT_ETW_EVENT_HC_ASYNC_SCHEDULE_ENABLE;
		case 9: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_ASYNC_SCHEDULE_DISABLE USBPORT_ETW_EVENT_HC_ASYNC_SCHEDULE_DISABLE;
		case 10: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_PERIODIC_SCHEDULE_ENABLE USBPORT_ETW_EVENT_HC_PERIODIC_SCHEDULE_ENABLE;
		case 11: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_PERIODIC_SCHEDULE_DISABLE USBPORT_ETW_EVENT_HC_PERIODIC_SCHEDULE_DISABLE;
		case 12: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DEVICE_CREATE USBPORT_ETW_EVENT_DEVICE_CREATE;
		case 13: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DEVICE_INITIALIZE USBPORT_ETW_EVENT_DEVICE_INITIALIZE;
		case 14: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DEVICE_REMOVAL USBPORT_ETW_EVENT_DEVICE_REMOVAL;
		case 15: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DEVICE_INFORMATION USBPORT_ETW_EVENT_DEVICE_INFORMATION;
		case 16: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DEVICE_IDLE_STATE_SET USBPORT_ETW_EVENT_DEVICE_IDLE_STATE_SET;
		case 17: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DEVICE_IDLE_STATE_CLEAR USBPORT_ETW_EVENT_DEVICE_IDLE_STATE_CLEAR;
		case 18: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_ENDPOINT_OPEN USBPORT_ETW_EVENT_ENDPOINT_OPEN;
		case 19: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_ENDPOINT_CLOSE USBPORT_ETW_EVENT_ENDPOINT_CLOSE;
		case 20: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_ENDPOINT_INFORMATION USBPORT_ETW_EVENT_ENDPOINT_INFORMATION;
		case 21: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_SELECT_CONFIGURATION USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_SELECT_CONFIGURATION;
		case 22: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_SELECT_INTERFACE USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_SELECT_INTERFACE;
		case 23: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_GET_CURRENT_FRAME_NUMBER USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_GET_CURRENT_FRAME_NUMBER;
		case 24: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_CONTROL_TRANSFER USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_CONTROL_TRANSFER;
		case 25: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_CONTROL_TRANSFER_EX USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_CONTROL_TRANSFER_EX;
		case 26: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;
		case 27: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_ISOCH_TRANSFER USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_ISOCH_TRANSFER;
		case 28: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE;
		case 29: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_SET_DESCRIPTOR_TO_DEVICE USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_SET_DESCRIPTOR_TO_DEVICE;
		case 30: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT;
		case 31: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_SET_DESCRIPTOR_TO_ENDPOINT USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_SET_DESCRIPTOR_TO_ENDPOINT;
		case 32: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE;
		case 33: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_SET_DESCRIPTOR_TO_INTERFACE USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_SET_DESCRIPTOR_TO_INTERFACE;
		case 34: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_SET_FEATURE_TO_DEVICE USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_SET_FEATURE_TO_DEVICE;
		case 35: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_SET_FEATURE_TO_INTERFACE USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_SET_FEATURE_TO_INTERFACE;
		case 36: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_SET_FEATURE_TO_ENDPOINT USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_SET_FEATURE_TO_ENDPOINT;
		case 37: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_CLEAR_FEATURE_TO_DEVICE USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_CLEAR_FEATURE_TO_DEVICE;
		case 38: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_CLEAR_FEATURE_TO_INTERFACE USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_CLEAR_FEATURE_TO_INTERFACE;
		case 39: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT;
		case 40: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_CLEAR_FEATURE_TO_OTHER USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_CLEAR_FEATURE_TO_OTHER;
		case 41: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_SET_FEATURE_TO_OTHER USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_SET_FEATURE_TO_OTHER;
		case 42: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_GET_STATUS_FROM_DEVICE USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_GET_STATUS_FROM_DEVICE;
		case 43: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_GET_STATUS_FROM_INTERFACE USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_GET_STATUS_FROM_INTERFACE;
		case 44: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_GET_STATUS_FROM_ENDPOINT USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_GET_STATUS_FROM_ENDPOINT;
		case 45: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_GET_STATUS_FROM_OTHER USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_GET_STATUS_FROM_OTHER;
		case 46: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_VENDOR_DEVICE USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_VENDOR_DEVICE;
		case 47: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_VENDOR_INTERFACE USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_VENDOR_INTERFACE;
		case 48: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_VENDOR_ENDPOINT USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_VENDOR_ENDPOINT;
		case 49: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_CLASS_DEVICE USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_CLASS_DEVICE;
		case 50: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_CLASS_INTERFACE USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_CLASS_INTERFACE;
		case 51: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_CLASS_ENDPOINT USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_CLASS_ENDPOINT;
		case 52: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_CLASS_OTHER USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_CLASS_OTHER;
		case 53: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_VENDOR_OTHER USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_VENDOR_OTHER;
		case 54: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_ABORT_PIPE USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_ABORT_PIPE;
		case 55: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_SYNC_RESET_PIPE_AND_CLEAR_STALL USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_SYNC_RESET_PIPE_AND_CLEAR_STALL;
		case 56: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_SYNC_RESET_PIPE USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_SYNC_RESET_PIPE;
		case 57: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_SYNC_CLEAR_STALL USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_SYNC_CLEAR_STALL;
		case 58: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_GET_CONFIGURATION USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_GET_CONFIGURATION;
		case 59: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_GET_INTERFACE USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_GET_INTERFACE;
		case 60: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_GET_MS_FEATURE_DESCRIPTOR USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_GET_MS_FEATURE_DESCRIPTOR;
		case 61: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_TAKE_FRAME_LENGTH_CONTROL USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_TAKE_FRAME_LENGTH_CONTROL;
		case 62: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_RELEASE_FRAME_LENGTH_CONTROL USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_RELEASE_FRAME_LENGTH_CONTROL;
		case 63: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_GET_FRAME_LENGTH USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_GET_FRAME_LENGTH;
		case 64: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_SET_FRAME_LENGTH USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_SET_FRAME_LENGTH;
		case 65: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_RESERVED USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_RESERVED;
		case 66: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_COMPLETE_URB_FUNCTION_CONTROL_TRANSFER USBPORT_ETW_EVENT_COMPLETE_URB_FUNCTION_CONTROL_TRANSFER;
		case 67: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_COMPLETE_URB_FUNCTION_CONTROL_TRANSFER_EX USBPORT_ETW_EVENT_COMPLETE_URB_FUNCTION_CONTROL_TRANSFER_EX;
		case 68: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_COMPLETE_URB_FUNCTION_CONTROL_TRANSFER_DATA USBPORT_ETW_EVENT_COMPLETE_URB_FUNCTION_CONTROL_TRANSFER_DATA;
		case 69: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_COMPLETE_URB_FUNCTION_CONTROL_TRANSFER_EX_DATA USBPORT_ETW_EVENT_COMPLETE_URB_FUNCTION_CONTROL_TRANSFER_EX_DATA;
		case 70: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_COMPLETE_URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER USBPORT_ETW_EVENT_COMPLETE_URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;
		case 71: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_COMPLETE_URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER_DATA USBPORT_ETW_EVENT_COMPLETE_URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER_DATA;
		case 72: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_COMPLETE_URB_FUNCTION_ISOCH_TRANSFER USBPORT_ETW_EVENT_COMPLETE_URB_FUNCTION_ISOCH_TRANSFER;
		case 73: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_COMPLETE_URB_FUNCTION_ISOCH_TRANSFER_DATA USBPORT_ETW_EVENT_COMPLETE_URB_FUNCTION_ISOCH_TRANSFER_DATA;
		case 74: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_INTERNAL_URB_FUNCTION_CONTROL_TRANSFER USBPORT_ETW_EVENT_INTERNAL_URB_FUNCTION_CONTROL_TRANSFER;
		case 75: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_COMPLETE_INTERNAL_URB_FUNCTION_CONTROL_TRANSFER USBPORT_ETW_EVENT_COMPLETE_INTERNAL_URB_FUNCTION_CONTROL_TRANSFER;
		case 76: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_COMPLETE_INTERNAL_URB_FUNCTION_CONTROL_TRANSFER_DATA USBPORT_ETW_EVENT_COMPLETE_INTERNAL_URB_FUNCTION_CONTROL_TRANSFER_DATA;
		case 77: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_COMPLETE_URB_FUNCTION_ABORT_PIPE USBPORT_ETW_EVENT_COMPLETE_URB_FUNCTION_ABORT_PIPE;
		case 78: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_HEADER_LENGTH_WARNING USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_HEADER_LENGTH_WARNING;
		case 79: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_FUNCTION USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_FUNCTION;
		case 80: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_HEADER_LENGTH USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_HEADER_LENGTH;
		case 81: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_DEVICE_HANDLE USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_DEVICE_HANDLE;
		case 82: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_FUNCTION_NOT_SUPPORTED USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_FUNCTION_NOT_SUPPORTED;
		case 83: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_FUNCTION_RESERVED USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_FUNCTION_RESERVED;
		case 84: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_DUE_TO_HC_SUSPEND USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_DUE_TO_HC_SUSPEND;
		case 85: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_URB_LINK USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_URB_LINK;
		case 86: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_PIPE_HANDLE USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_PIPE_HANDLE;
		case 87: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_ZERO_BW_PIPE_HANDLE USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_ZERO_BW_PIPE_HANDLE;
		case 88: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_NOP_ZERO_BW_PIPE_HANDLE_REQUEST USBPORT_ETW_EVENT_DISPATCH_URB_NOP_ZERO_BW_PIPE_HANDLE_REQUEST;
		case 89: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_CONTROL_TRANSFER_ENDPOINT USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_CONTROL_TRANSFER_ENDPOINT;
		case 90: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_CONTROL_TRANSFER_BUFFER_LENGTH USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_CONTROL_TRANSFER_BUFFER_LENGTH;
		case 91: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_BULK_OR_INTERRUPT_TRANSFER_ENDPOINT USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_BULK_OR_INTERRUPT_TRANSFER_ENDPOINT;
		case 92: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_BULK_OR_INTERRUPT_TRANSFER_BUFFER_LENGTH USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_BULK_OR_INTERRUPT_TRANSFER_BUFFER_LENGTH;
		case 93: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_ISOCHRONOUS_TRANSFER_ENDPOINT USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_ISOCHRONOUS_TRANSFER_ENDPOINT;
		case 94: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_NULL_TRANSFER_BUFFER_AND_MDL USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_NULL_TRANSFER_BUFFER_AND_MDL;
		case 95: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_NON_NULL_TRANSFER_BUFFER_MDL USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_NON_NULL_TRANSFER_BUFFER_MDL;
		case 96: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_ALLOCATE_MDL_FAILURE USBPORT_ETW_EVENT_DISPATCH_URB_ALLOCATE_MDL_FAILURE;
		case 97: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_ALLOCATE_TRANSFER_CONTEXT_FAILURE USBPORT_ETW_EVENT_DISPATCH_URB_ALLOCATE_TRANSFER_CONTEXT_FAILURE;
		case 98: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_NOP_ROOTHUB_PIPE_HANDLE_REQUEST USBPORT_ETW_EVENT_DISPATCH_URB_NOP_ROOTHUB_PIPE_HANDLE_REQUEST;
		case 99: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_ISOCHRONOUS_ZERO_LENGTH USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_ISOCHRONOUS_ZERO_LENGTH;
		case 100: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_ISOCHRONOUS_NUM_PACKETS USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_ISOCHRONOUS_NUM_PACKETS;
		case 101: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_ISOCHRONOUS_START_FRAME USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_ISOCHRONOUS_START_FRAME;
		case 102: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_IRP_CANCEL USBPORT_ETW_EVENT_IRP_CANCEL;
		case 103: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_USBUSER_OP_RAW_RESET_PORT_DISPATCH USBPORT_ETW_EVENT_USBUSER_OP_RAW_RESET_PORT_DISPATCH;
		case 104: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_USBUSER_OP_RAW_RESET_PORT_STATUS1 USBPORT_ETW_EVENT_USBUSER_OP_RAW_RESET_PORT_STATUS1;
		case 105: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_USBUSER_OP_RAW_RESET_PORT_STATUS2 USBPORT_ETW_EVENT_USBUSER_OP_RAW_RESET_PORT_STATUS2;
		case 106: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_USBUSER_OP_RAW_RESET_PORT_STATUS3 USBPORT_ETW_EVENT_USBUSER_OP_RAW_RESET_PORT_STATUS3;
		case 107: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_USBUSER_OP_RAW_RESET_PORT_COMPLETE USBPORT_ETW_EVENT_USBUSER_OP_RAW_RESET_PORT_COMPLETE;
		case 108: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_USBUSER_OP_SEND_ONE_PACKET_DISPATCH USBPORT_ETW_EVENT_USBUSER_OP_SEND_ONE_PACKET_DISPATCH;
		case 109: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_USBUSER_OP_SEND_ONE_PACKET_DISPATCH_DATA USBPORT_ETW_EVENT_USBUSER_OP_SEND_ONE_PACKET_DISPATCH_DATA;
		case 110: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_USBUSER_OP_SEND_ONE_PACKET_TIMEOUT USBPORT_ETW_EVENT_USBUSER_OP_SEND_ONE_PACKET_TIMEOUT;
		case 111: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_USBUSER_OP_SEND_ONE_PACKET_COMPLETE USBPORT_ETW_EVENT_USBUSER_OP_SEND_ONE_PACKET_COMPLETE;
		case 112: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_USBUSER_OP_SEND_ONE_PACKET_COMPLETE_DATA USBPORT_ETW_EVENT_USBUSER_OP_SEND_ONE_PACKET_COMPLETE_DATA;
		case 113: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_CODE_EXECUTION_TIME USBPORT_ETW_EVENT_CODE_EXECUTION_TIME;
		case 114: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_PUT_SGLIST_EXECUTION_TIME USBPORT_ETW_EVENT_PUT_SGLIST_EXECUTION_TIME;
		case 115: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_BUILD_SGLIST_EXECUTION_TIME USBPORT_ETW_EVENT_BUILD_SGLIST_EXECUTION_TIME;
		case 1024: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_START_DISPATCH USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_START_DISPATCH;
		case 1025: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_START_COMPLETE USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_START_COMPLETE;
		case 1026: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_START_COMPLETE_ERROR_1 USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_START_COMPLETE_ERROR_1;
		case 1027: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_START_COMPLETE_ERROR_2 USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_START_COMPLETE_ERROR_2;
		case 1028: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_START_COMPLETE_ERROR_3 USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_START_COMPLETE_ERROR_3;
		case 1029: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_START_COMPLETE_ERROR_4 USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_START_COMPLETE_ERROR_4;
		case 1030: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_START_COMPLETE_ERROR_5 USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_START_COMPLETE_ERROR_5;
		case 1031: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_STOP_DISPATCH USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_STOP_DISPATCH;
		case 1032: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_STOP_COMPLETE USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_STOP_COMPLETE;
		case 1033: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_SUSPEND_DISPATCH USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_SUSPEND_DISPATCH;
		case 1034: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_SUSPEND_COMPLETE USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_SUSPEND_COMPLETE;
		case 1035: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_RESUME_DISPATCH USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_RESUME_DISPATCH;
		case 1036: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_RESUME_COMPLETE USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_RESUME_COMPLETE;
		case 1037: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_RESUME_COMPLETE_ERROR_1 USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_RESUME_COMPLETE_ERROR_1;
		case 1038: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_RESUME_COMPLETE_ERROR_2 USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_RESUME_COMPLETE_ERROR_2;
		case 1039: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_RESUME_COMPLETE_ERROR_3 USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_RESUME_COMPLETE_ERROR_3;
		case 1040: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_RESUME_COMPLETE_ERROR_4 USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_RESUME_COMPLETE_ERROR_4;
		case 1041: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_RESUME_COMPLETE_ERROR_5 USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_RESUME_COMPLETE_ERROR_5;
		case 1042: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_RESUME_COMPLETE_ERROR_6 USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_RESUME_COMPLETE_ERROR_6;
		case 1043: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_DEVICE_DATA USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_DEVICE_DATA;
		case 2048: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_START_DISPATCH USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_START_DISPATCH;
		case 2049: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_START_COMPLETE USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_START_COMPLETE;
		case 2050: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_START_COMPLETE_ERROR_1 USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_START_COMPLETE_ERROR_1;
		case 2051: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_START_COMPLETE_ERROR_2 USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_START_COMPLETE_ERROR_2;
		case 2052: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_START_COMPLETE_ERROR_3 USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_START_COMPLETE_ERROR_3;
		case 2053: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_START_COMPLETE_ERROR_4 USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_START_COMPLETE_ERROR_4;
		case 2054: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_START_COMPLETE_ERROR_5 USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_START_COMPLETE_ERROR_5;
		case 2055: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_STOP_DISPATCH USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_STOP_DISPATCH;
		case 2056: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_STOP_COMPLETE USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_STOP_COMPLETE;
		case 2057: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_SUSPEND_DISPATCH USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_SUSPEND_DISPATCH;
		case 2058: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_SUSPEND_COMPLETE USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_SUSPEND_COMPLETE;
		case 2059: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_RESUME_DISPATCH USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_RESUME_DISPATCH;
		case 2060: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_RESUME_COMPLETE USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_RESUME_COMPLETE;
		case 2061: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_RESUME_COMPLETE_ERROR_1 USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_RESUME_COMPLETE_ERROR_1;
		case 2062: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_RESUME_COMPLETE_ERROR_2 USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_RESUME_COMPLETE_ERROR_2;
		case 2063: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_RESUME_COMPLETE_ERROR_3 USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_RESUME_COMPLETE_ERROR_3;
		case 2064: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_RESUME_COMPLETE_ERROR_4 USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_RESUME_COMPLETE_ERROR_4;
		case 2065: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_RESUME_COMPLETE_ERROR_5 USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_RESUME_COMPLETE_ERROR_5;
		case 3072: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_UHCI_MINIPORT_START_DISPATCH USBPORT_ETW_EVENT_HC_UHCI_MINIPORT_START_DISPATCH;
		case 3073: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_UHCI_MINIPORT_START_COMPLETE USBPORT_ETW_EVENT_HC_UHCI_MINIPORT_START_COMPLETE;
		case 3074: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_UHCI_MINIPORT_START_COMPLETE_ERROR_1 USBPORT_ETW_EVENT_HC_UHCI_MINIPORT_START_COMPLETE_ERROR_1;
		case 3075: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_UHCI_MINIPORT_START_COMPLETE_ERROR_2 USBPORT_ETW_EVENT_HC_UHCI_MINIPORT_START_COMPLETE_ERROR_2;
		case 3076: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_UHCI_MINIPORT_START_COMPLETE_ERROR_3 USBPORT_ETW_EVENT_HC_UHCI_MINIPORT_START_COMPLETE_ERROR_3;
		case 3077: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_UHCI_MINIPORT_START_COMPLETE_ERROR_4 USBPORT_ETW_EVENT_HC_UHCI_MINIPORT_START_COMPLETE_ERROR_4;
		case 3078: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_UHCI_MINIPORT_STOP_DISPATCH USBPORT_ETW_EVENT_HC_UHCI_MINIPORT_STOP_DISPATCH;
		case 3079: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_UHCI_MINIPORT_STOP_COMPLETE USBPORT_ETW_EVENT_HC_UHCI_MINIPORT_STOP_COMPLETE;
		case 3080: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_UHCI_MINIPORT_SUSPEND_DISPATCH USBPORT_ETW_EVENT_HC_UHCI_MINIPORT_SUSPEND_DISPATCH;
		case 3081: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_UHCI_MINIPORT_SUSPEND_COMPLETE USBPORT_ETW_EVENT_HC_UHCI_MINIPORT_SUSPEND_COMPLETE;
		case 3082: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_UHCI_MINIPORT_RESUME_DISPATCH USBPORT_ETW_EVENT_HC_UHCI_MINIPORT_RESUME_DISPATCH;
		case 3083: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_UHCI_MINIPORT_RESUME_COMPLETE USBPORT_ETW_EVENT_HC_UHCI_MINIPORT_RESUME_COMPLETE;
		case 3084: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_UHCI_MINIPORT_RESUME_COMPLETE_ERROR_1 USBPORT_ETW_EVENT_HC_UHCI_MINIPORT_RESUME_COMPLETE_ERROR_1;
		case 3085: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_UHCI_MINIPORT_RESUME_COMPLETE_ERROR_2 USBPORT_ETW_EVENT_HC_UHCI_MINIPORT_RESUME_COMPLETE_ERROR_2;
		case 3086: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_UHCI_MINIPORT_RESUME_COMPLETE_ERROR_3 USBPORT_ETW_EVENT_HC_UHCI_MINIPORT_RESUME_COMPLETE_ERROR_3;
		case 3087: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_UHCI_MINIPORT_RESUME_COMPLETE_ERROR_4 USBPORT_ETW_EVENT_HC_UHCI_MINIPORT_RESUME_COMPLETE_ERROR_4;
		case 3088: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_HC_UHCI_MINIPORT_RESUME_COMPLETE_ERROR_5 USBPORT_ETW_EVENT_HC_UHCI_MINIPORT_RESUME_COMPLETE_ERROR_5;
		case 3089: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_RTPM_TRANSITION USBPORT_ETW_EVENT_RTPM_TRANSITION;
		case 3090: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_DISPATCH_WAIT_WAKE USBPORT_ETW_EVENT_DISPATCH_WAIT_WAKE;
		case 3091: [property.ETLSummary = this.ToString] USBPort_USBPORT_ETW_EVENT_COMPLETE_WAIT_WAKE USBPORT_ETW_EVENT_COMPLETE_WAIT_WAKE;
		default: [property.ETLSummary = "Not exist EventID"]struct{};
	}
}
Table RunTimePmSetupStatus(value)
{
	switch(value)
	{
		case 0: "Successful";
		case 1: "FailedDueToCompanionController";
		case 2: "FailedDueToNoS0WakeSupport";
		case 3: "FailedDueToFailedPoRegistration";
		default:
			FormatString("Unknown value: %d", value);
	}
}
Table RunTimePmEvent(value)
{
	switch(value)
	{
		case 0: "PowerRequiredCallbackInvoked";
		case 1: "PowerNotRequiredCallbackInvoked";
		case 2: "ActiveCallbackInvoked";
		case 3: "IdleCallbackInvoked";
		case 4: "EnteredD0";
		case 5: "EnteredD2";
		case 6: "EnteredD3";
		default:
			FormatString("Unknown value: %d", value);
	}
}
Struct USBPort_USBPORT_ETW_EVENT_HC_ADD = FormatString("Host Controller Add")
{
	USBPort_HostController2 HostController;
}
Struct USBPort_USBPORT_ETW_EVENT_HC_REMOVAL = FormatString("Host Controller Removal")
{
	USBPort_HostController2 HostController;
}
Struct USBPort_USBPORT_ETW_EVENT_HC_INFORMATION = FormatString("Host Controller Information")
{
	// Get to the host controller conversation just so we can modify the USBIsEhci property of the conversation (not sure how this works exactly)
	[Post.ProxyBuildConversationWithParent("USB", USBPort_HostController.ToString)]
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_HC_Idle_Status
	{
		[Conversation.USBIsEhci = this]
		UINT8 fid_HC_HighSpeed;
		UINT8 fid_HC_Run;
		UINT8 fid_HC_AsyncScheduleEnable;
		UINT8 fid_HC_PeriodicScheduleEnable;
	}
	UnicodeString fid_USBPORT_HC_Pdo_Name;
	UINT32 fid_RunTimePmSetupStatus = RunTimePmSetupStatus(this);
	UINT32 fid_DevicePowerState;
	AsciiString fid_AcpiInstanceId;
}
Struct USBPort_USBPORT_ETW_EVENT_HC_START = FormatString("Host Controller Start")
{
	USBPort_HostController2 HostController;
}
Struct USBPort_USBPORT_ETW_EVENT_HC_STOP = FormatString("Host Controller Stop")
{
	USBPort_HostController2 HostController;
}
Struct USBPort_USBPORT_ETW_EVENT_HC_SUSPEND = FormatString("Host Controller Suspend")
{
	USBPort_HostController2 HostController;
}
Struct USBPort_USBPORT_ETW_EVENT_HC_RESUME = FormatString("Host Controller Resume")
{
	USBPort_HostController2 HostController;
}
Struct USBPort_USBPORT_ETW_EVENT_HC_ASYNC_SCHEDULE_ENABLE = FormatString("Host Controller Async Schedule Enable")
{
	USBPort_HostController2 HostController;
}
Struct USBPort_USBPORT_ETW_EVENT_HC_ASYNC_SCHEDULE_DISABLE = FormatString("Host Controller Async Schedule Disable")
{
	USBPort_HostController2 HostController;
}
Struct USBPort_USBPORT_ETW_EVENT_HC_PERIODIC_SCHEDULE_ENABLE = FormatString("Host Controller Periodic Schedule Enable")
{
	USBPort_HostController2 HostController;
}
Struct USBPort_USBPORT_ETW_EVENT_HC_PERIODIC_SCHEDULE_DISABLE = FormatString("Host Controller Periodic Schedule Disable")
{
	USBPort_HostController2 HostController;
}
Struct USBPort_USBPORT_ETW_EVENT_DEVICE_CREATE = FormatString("Device Create")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	USB_DEVICE_DESCRIPTOR fid_USBPORT_Device_Descriptor;
}
Struct USBPort_USBPORT_ETW_EVENT_DEVICE_INITIALIZE = FormatString("Device Initialize")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	USB_DEVICE_DESCRIPTOR fid_USBPORT_Device_Descriptor;
}
Struct USBPort_USBPORT_ETW_EVENT_DEVICE_REMOVAL = FormatString("Device Removal")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
}
Struct USBPort_USBPORT_ETW_EVENT_DEVICE_INFORMATION = FormatString("Device Information")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	USB_DEVICE_DESCRIPTOR fid_USBPORT_Device_Descriptor;
	UnicodeString(16) fid_USBPORT_Device_Driver_Name;
	UINT32 fid_USBPORT_Device_Idle_State;
	UnicodeString fid_USBPORT_Device_Pdo_Name;
}
Struct USBPort_USBPORT_ETW_EVENT_DEVICE_IDLE_STATE_SET = FormatString("Device Idle State Set")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	UINT32 fid_USBPORT_Device_Idle_Previous_State;
	UINT32 fid_USBPORT_Device_Idle_New_State;
}
Struct USBPort_USBPORT_ETW_EVENT_DEVICE_IDLE_STATE_CLEAR = FormatString("Device Idle State Clear")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	UINT32 fid_USBPORT_Device_Idle_Previous_State;
	UINT32 fid_USBPORT_Device_Idle_New_State;
}
Struct USBPort_USBPORT_ETW_EVENT_ENDPOINT_OPEN = FormatString("Endpoint Open")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
}
Struct USBPort_USBPORT_ETW_EVENT_ENDPOINT_CLOSE = FormatString("Endpoint Close")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
}
Struct USBPort_USBPORT_ETW_EVENT_ENDPOINT_INFORMATION = FormatString("Endpoint Information")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_SELECT_CONFIGURATION = FormatString("Dispatch URB_FUNCTION_SELECT_CONFIGURATION")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	UINT16 fid_URB_Length;
	UINT8 fid_URB[fid_URB_Length];
	UINT16 fid_Configuration_Descriptor_Length;
	UINT8 fid_Configuration_Descriptor[fid_Configuration_Descriptor_Length];
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_SELECT_INTERFACE = FormatString("Dispatch URB_FUNCTION_SELECT_INTERFACE")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	UINT16 fid_URB_Length;
	UINT8 fid_URB[fid_URB_Length];
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_GET_CURRENT_FRAME_NUMBER = FormatString("Dispatch URB_FUNCTION_GET_CURRENT_FRAME_NUMBER")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	UINT32 fid_URB_FrameNumber;
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_CONTROL_TRANSFER = FormatString("Dispatch URB_FUNCTION_CONTROL_TRANSFER")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	CONTROL_TRANSFER_URB_SETUP ControlTransfer;
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_CONTROL_TRANSFER_EX = FormatString("Dispatch URB_FUNCTION_CONTROL_TRANSFER_EX")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	CONTROL_TRANSFER_URB_SETUP ControlTransfer;
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER = FormatString("Dispatch URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	URB Urb;
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_ISOCH_TRANSFER = FormatString("Dispatch URB_FUNCTION_ISOCH_TRANSFER")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	UINT16 fid_USBPORT_URB_NumberOfPackets;
	URB Urb;
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE = FormatString("Dispatch URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	CONTROL_TRANSFER_URB_SETUP ControlTransfer;
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_SET_DESCRIPTOR_TO_DEVICE = FormatString("Dispatch URB_FUNCTION_SET_DESCRIPTOR_TO_DEVICE")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	CONTROL_TRANSFER_URB_SETUP ControlTransfer;
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT = FormatString("Dispatch URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	CONTROL_TRANSFER_URB_SETUP ControlTransfer;
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_SET_DESCRIPTOR_TO_ENDPOINT = FormatString("Dispatch URB_FUNCTION_SET_DESCRIPTOR_TO_ENDPOINT")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	CONTROL_TRANSFER_URB_SETUP ControlTransfer;
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE = FormatString("Dispatch URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	CONTROL_TRANSFER_URB_SETUP ControlTransfer;
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_SET_DESCRIPTOR_TO_INTERFACE = FormatString("Dispatch URB_FUNCTION_SET_DESCRIPTOR_TO_INTERFACE")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	CONTROL_TRANSFER_URB_SETUP ControlTransfer;
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_SET_FEATURE_TO_DEVICE = FormatString("Dispatch URB_FUNCTION_SET_FEATURE_TO_DEVICE")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	CONTROL_TRANSFER_URB_SETUP ControlTransfer;
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_SET_FEATURE_TO_INTERFACE = FormatString("Dispatch URB_FUNCTION_SET_FEATURE_TO_INTERFACE")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	CONTROL_TRANSFER_URB_SETUP ControlTransfer;
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_SET_FEATURE_TO_ENDPOINT = FormatString("Dispatch URB_FUNCTION_SET_FEATURE_TO_ENDPOINT")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	CONTROL_TRANSFER_URB_SETUP ControlTransfer;
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_CLEAR_FEATURE_TO_DEVICE = FormatString("Dispatch URB_FUNCTION_CLEAR_FEATURE_TO_DEVICE")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	CONTROL_TRANSFER_URB_SETUP ControlTransfer;
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_CLEAR_FEATURE_TO_INTERFACE = FormatString("Dispatch URB_FUNCTION_CLEAR_FEATURE_TO_INTERFACE")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	CONTROL_TRANSFER_URB_SETUP ControlTransfer;
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT = FormatString("Dispatch URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	CONTROL_TRANSFER_URB_SETUP ControlTransfer;
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_CLEAR_FEATURE_TO_OTHER = FormatString("Dispatch URB_FUNCTION_CLEAR_FEATURE_TO_OTHER")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	CONTROL_TRANSFER_URB_SETUP ControlTransfer;
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_SET_FEATURE_TO_OTHER = FormatString("Dispatch URB_FUNCTION_SET_FEATURE_TO_OTHER")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	CONTROL_TRANSFER_URB_SETUP ControlTransfer;
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_GET_STATUS_FROM_DEVICE = FormatString("Dispatch URB_FUNCTION_GET_STATUS_FROM_DEVICE")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	CONTROL_TRANSFER_URB_SETUP ControlTransfer;
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_GET_STATUS_FROM_INTERFACE = FormatString("Dispatch URB_FUNCTION_GET_STATUS_FROM_INTERFACE")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	CONTROL_TRANSFER_URB_SETUP ControlTransfer;
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_GET_STATUS_FROM_ENDPOINT = FormatString("Dispatch URB_FUNCTION_GET_STATUS_FROM_ENDPOINT")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	CONTROL_TRANSFER_URB_SETUP ControlTransfer;
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_GET_STATUS_FROM_OTHER = FormatString("Dispatch URB_FUNCTION_GET_STATUS_FROM_OTHER")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	CONTROL_TRANSFER_URB_SETUP ControlTransfer;
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_VENDOR_DEVICE = FormatString("Dispatch URB_FUNCTION_VENDOR_DEVICE")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	CONTROL_TRANSFER_URB_SETUP ControlTransfer;
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_VENDOR_INTERFACE = FormatString("Dispatch URB_FUNCTION_VENDOR_INTERFACE")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	CONTROL_TRANSFER_URB_SETUP ControlTransfer;
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_VENDOR_ENDPOINT = FormatString("Dispatch URB_FUNCTION_VENDOR_ENDPOINT")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	CONTROL_TRANSFER_URB_SETUP ControlTransfer;
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_CLASS_DEVICE = FormatString("Dispatch URB_FUNCTION_CLASS_DEVICE")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	CONTROL_TRANSFER_URB_SETUP ControlTransfer;
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_CLASS_INTERFACE = FormatString("Dispatch URB_FUNCTION_CLASS_INTERFACE")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	CONTROL_TRANSFER_URB_SETUP ControlTransfer;
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_CLASS_ENDPOINT = FormatString("Dispatch URB_FUNCTION_CLASS_ENDPOINT")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	CONTROL_TRANSFER_URB_SETUP ControlTransfer;
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_CLASS_OTHER = FormatString("Dispatch URB_FUNCTION_CLASS_OTHER")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	CONTROL_TRANSFER_URB_SETUP ControlTransfer;
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_VENDOR_OTHER = FormatString("Dispatch URB_FUNCTION_VENDOR_OTHER")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	CONTROL_TRANSFER_URB_SETUP ControlTransfer;
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_ABORT_PIPE = FormatString("Dispatch URB_FUNCTION_ABORT_PIPE")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	struct 	fid_USBPORT_URB_URB_PIPE_REQUEST
	{
		UINT16 fid_URB_Hdr_Length;
		UINT16 fid_URB_Hdr_Function;
		UINT32 fid_URB_Hdr_Status;
		EtlPtr fid_URB_Hdr_UsbdDeviceHandle;
		EtlPtr fid_URB_Hdr_UsbdFlags;
		EtlPtr fid_URB_PipeHandle;
		UINT32 fid_Reserved;
	}
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_SYNC_RESET_PIPE_AND_CLEAR_STALL = FormatString("Dispatch URB_FUNCTION_SYNC_RESET_PIPE_AND_CLEAR_STALL")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	struct 	fid_USBPORT_URB_URB_PIPE_REQUEST
	{
		UINT16 fid_URB_Hdr_Length;
		UINT16 fid_URB_Hdr_Function;
		UINT32 fid_URB_Hdr_Status;
		EtlPtr fid_URB_Hdr_UsbdDeviceHandle;
		EtlPtr fid_URB_Hdr_UsbdFlags;
		EtlPtr fid_URB_PipeHandle;
		UINT32 fid_Reserved;
	}
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_SYNC_RESET_PIPE = FormatString("Dispatch URB_FUNCTION_SYNC_RESET_PIPE")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	struct 	fid_USBPORT_URB_URB_PIPE_REQUEST
	{
		UINT16 fid_URB_Hdr_Length;
		UINT16 fid_URB_Hdr_Function;
		UINT32 fid_URB_Hdr_Status;
		EtlPtr fid_URB_Hdr_UsbdDeviceHandle;
		EtlPtr fid_URB_Hdr_UsbdFlags;
		EtlPtr fid_URB_PipeHandle;
		UINT32 fid_Reserved;
	}
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_SYNC_CLEAR_STALL = FormatString("Dispatch URB_FUNCTION_SYNC_CLEAR_STALL")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	struct 	fid_USBPORT_URB_URB_PIPE_REQUEST
	{
		UINT16 fid_URB_Hdr_Length;
		UINT16 fid_URB_Hdr_Function;
		UINT32 fid_URB_Hdr_Status;
		EtlPtr fid_URB_Hdr_UsbdDeviceHandle;
		EtlPtr fid_URB_Hdr_UsbdFlags;
		EtlPtr fid_URB_PipeHandle;
		UINT32 fid_Reserved;
	}
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_GET_CONFIGURATION = FormatString("Dispatch URB_FUNCTION_GET_CONFIGURATION")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	CONTROL_TRANSFER_URB_SETUP ControlTransfer;
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_GET_INTERFACE = FormatString("Dispatch URB_FUNCTION_GET_INTERFACE")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	CONTROL_TRANSFER_URB_SETUP ControlTransfer;
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_GET_MS_FEATURE_DESCRIPTOR = FormatString("Dispatch URB_FUNCTION_GET_MS_FEATURE_DESCRIPTOR")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	CONTROL_TRANSFER_URB_SETUP ControlTransfer;
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_TAKE_FRAME_LENGTH_CONTROL = "Dispatch URB_FUNCTION_TAKE_FRAME_LENGTH_CONTROL" {}; // Empty Struct
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_RELEASE_FRAME_LENGTH_CONTROL = "Dispatch URB_FUNCTION_RELEASE_FRAME_LENGTH_CONTROL" {}; // Empty Struct
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_GET_FRAME_LENGTH = "Dispatch URB_FUNCTION_GET_FRAME_LENGTH" {}; // Empty Struct
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_SET_FRAME_LENGTH = "Dispatch URB_FUNCTION_SET_FRAME_LENGTH" {}; // Empty Struct
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_FUNCTION_RESERVED = "Dispatch URB_FUNCTION_RESERVED" {}; // Empty Struct

[Property.InternalUsbIsUrbCompletion = 1]
Struct USBPort_USBPORT_ETW_EVENT_COMPLETE_URB_FUNCTION_CONTROL_TRANSFER = FormatString("Complete URB_FUNCTION_CONTROL_TRANSFER")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	CONTROL_TRANSFER_URB_SETUP ControlTransfer;
}
[Property.InternalUsbIsUrbCompletion = 1]
Struct USBPort_USBPORT_ETW_EVENT_COMPLETE_URB_FUNCTION_CONTROL_TRANSFER_EX = FormatString("Complete URB_FUNCTION_CONTROL_TRANSFER_EX")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	CONTROL_TRANSFER_URB_SETUP ControlTransfer;
}
[Property.InternalUsbIsUrbCompletion = 1]
Struct USBPort_USBPORT_ETW_EVENT_COMPLETE_URB_FUNCTION_CONTROL_TRANSFER_DATA = FormatString("Complete URB_FUNCTION_CONTROL_TRANSFER with Data")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	CONTROL_TRANSFER_URB_SETUP_AND_DATA ControlTransfer;
}
[Property.InternalUsbIsUrbCompletion = 1]
Struct USBPort_USBPORT_ETW_EVENT_COMPLETE_URB_FUNCTION_CONTROL_TRANSFER_EX_DATA = FormatString("Complete URB_FUNCTION_CONTROL_TRANSFER_EX with Data")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	CONTROL_TRANSFER_URB_SETUP_AND_DATA ControlTransfer;
}
[Property.InternalUsbIsUrbCompletion = 1]
Struct USBPort_USBPORT_ETW_EVENT_COMPLETE_URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER = FormatString("Complete URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	URB Urb;
}
[Property.InternalUsbIsUrbCompletion = 1]
Struct USBPort_USBPORT_ETW_EVENT_COMPLETE_URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER_DATA = FormatString("Complete URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER with Data")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	URB Urb;
	UINT16 fid_URB_TransferDataLength;
	UINT8 fid_URB_TransferData[fid_URB_TransferDataLength];
}
[Property.InternalUsbIsUrbCompletion = 1]
Struct USBPort_USBPORT_ETW_EVENT_COMPLETE_URB_FUNCTION_ISOCH_TRANSFER = FormatString("Complete COMPLETE_URB_FUNCTION_ISOCH_TRANSFER")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	UINT16 fid_USBPORT_URB_NumberOfPackets;
	URB Urb;
}
[Property.InternalUsbIsUrbCompletion = 1]
Struct USBPort_USBPORT_ETW_EVENT_COMPLETE_URB_FUNCTION_ISOCH_TRANSFER_DATA = FormatString("Complete COMPLETE_URB_FUNCTION_ISOCH_TRANSFER with Data")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	UINT16 fid_USBPORT_URB_NumberOfPackets;
	URB Urb;
}
Struct USBPort_USBPORT_ETW_EVENT_INTERNAL_URB_FUNCTION_CONTROL_TRANSFER = FormatString("Internal URB_FUNCTION_CONTROL_TRANSFER")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	UsbUrbPtr fid_URB_Ptr;
	CONTROL_TRANSFER_URB_SETUP ControlTransfer;
}
[Property.InternalUsbIsUrbCompletion = 1]
Struct USBPort_USBPORT_ETW_EVENT_COMPLETE_INTERNAL_URB_FUNCTION_CONTROL_TRANSFER = FormatString("Complete Internal URB_FUNCTION_CONTROL_TRANSFER")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	UsbUrbPtr fid_URB_Ptr;
	CONTROL_TRANSFER_URB_SETUP ControlTransfer;
}
[Property.InternalUsbIsUrbCompletion = 1]
Struct USBPort_USBPORT_ETW_EVENT_COMPLETE_INTERNAL_URB_FUNCTION_CONTROL_TRANSFER_DATA = FormatString("Complete Internal URB_FUNCTION_CONTROL_TRANSFER with Data")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	UsbUrbPtr fid_URB_Ptr;
	CONTROL_TRANSFER_URB_SETUP_AND_DATA ControlTransfer;
}
[Property.InternalUsbIsUrbCompletion = 1]
Struct USBPort_USBPORT_ETW_EVENT_COMPLETE_URB_FUNCTION_ABORT_PIPE = FormatString("Complete URB_FUNCTION_ABORT_PIPE")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	struct 	fid_USBPORT_URB_URB_PIPE_REQUEST
	{
		UINT16 fid_URB_Hdr_Length;
		UINT16 fid_URB_Hdr_Function;
		UINT32 fid_URB_Hdr_Status;
		EtlPtr fid_URB_Hdr_UsbdDeviceHandle;
		EtlPtr fid_URB_Hdr_UsbdFlags;
		EtlPtr fid_URB_PipeHandle;
		UINT32 fid_Reserved;
	}
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_HEADER_LENGTH_WARNING = FormatString("Dispatch URB INVALID_HEADER_LENGTH_WARNING")
{
	USBPort_HostController2 HostController;
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	struct 	fid_USBPORT_URB_HEADER
	{
		UINT16 fid_URB_Hdr_Length;
		UINT16 fid_URB_Hdr_Function;
		UINT32 fid_URB_Hdr_Status;
		EtlPtr fid_URB_Hdr_UsbdDeviceHandle;
		EtlPtr fid_URB_Hdr_UsbdFlags;
	}
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_FUNCTION = FormatString("Dispatch URB INVALID_FUNCTION")
{
	USBPort_HostController2 HostController;
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	struct 	fid_USBPORT_URB_HEADER
	{
		UINT16 fid_URB_Hdr_Length;
		UINT16 fid_URB_Hdr_Function;
		UINT32 fid_URB_Hdr_Status;
		EtlPtr fid_URB_Hdr_UsbdDeviceHandle;
		EtlPtr fid_URB_Hdr_UsbdFlags;
	}
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_HEADER_LENGTH = FormatString("Dispatch URB INVALID_HEADER_LENGTH")
{
	USBPort_HostController2 HostController;
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	struct 	fid_USBPORT_URB_HEADER
	{
		UINT16 fid_URB_Hdr_Length;
		UINT16 fid_URB_Hdr_Function;
		UINT32 fid_URB_Hdr_Status;
		EtlPtr fid_URB_Hdr_UsbdDeviceHandle;
		EtlPtr fid_URB_Hdr_UsbdFlags;
	}
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_DEVICE_HANDLE = FormatString("Dispatch URB INVALID_DEVICE_HANDLE")
{
	USBPort_HostController2 HostController;
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	struct 	fid_USBPORT_URB_HEADER
	{
		UINT16 fid_URB_Hdr_Length;
		UINT16 fid_URB_Hdr_Function;
		UINT32 fid_URB_Hdr_Status;
		EtlPtr fid_URB_Hdr_UsbdDeviceHandle;
		EtlPtr fid_URB_Hdr_UsbdFlags;
	}
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_FUNCTION_NOT_SUPPORTED = FormatString("Dispatch URB INVALID_FUNCTION_NOT_SUPPORTED")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	struct 	fid_USBPORT_URB_HEADER
	{
		UINT16 fid_URB_Hdr_Length;
		UINT16 fid_URB_Hdr_Function;
		UINT32 fid_URB_Hdr_Status;
		EtlPtr fid_URB_Hdr_UsbdDeviceHandle;
		EtlPtr fid_URB_Hdr_UsbdFlags;
	}
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_FUNCTION_RESERVED = FormatString("Dispatch URB INVALID_FUNCTION_RESERVED")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	struct 	fid_USBPORT_URB_HEADER
	{
		UINT16 fid_URB_Hdr_Length;
		UINT16 fid_URB_Hdr_Function;
		UINT32 fid_URB_Hdr_Status;
		EtlPtr fid_URB_Hdr_UsbdDeviceHandle;
		EtlPtr fid_URB_Hdr_UsbdFlags;
	}
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_DUE_TO_HC_SUSPEND = FormatString("Dispatch URB INVALID_DUE_TO_HC_SUSPEND")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	struct 	fid_USBPORT_URB_HEADER
	{
		UINT16 fid_URB_Hdr_Length;
		UINT16 fid_URB_Hdr_Function;
		UINT32 fid_URB_Hdr_Status;
		EtlPtr fid_URB_Hdr_UsbdDeviceHandle;
		EtlPtr fid_URB_Hdr_UsbdFlags;
	}
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_URB_LINK = FormatString("Dispatch URB INVALID_URB_LINK")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	struct 	fid_USBPORT_URB_HEADER
	{
		UINT16 fid_URB_Hdr_Length;
		UINT16 fid_URB_Hdr_Function;
		UINT32 fid_URB_Hdr_Status;
		EtlPtr fid_URB_Hdr_UsbdDeviceHandle;
		EtlPtr fid_URB_Hdr_UsbdFlags;
	}
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_PIPE_HANDLE = FormatString("Dispatch URB INVALID_PIPE_HANDLE")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	struct 	fid_USBPORT_URB_INVALID_PIPE_REQUEST
	{
		UINT16 fid_URB_Hdr_Length;
		UINT16 fid_URB_Hdr_Function;
		UINT32 fid_URB_Hdr_Status;
		EtlPtr fid_URB_Hdr_UsbdDeviceHandle;
		EtlPtr fid_URB_Hdr_UsbdFlags;
		EtlPtr fid_URB_PipeHandle;
	}
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_ZERO_BW_PIPE_HANDLE = FormatString("Dispatch URB INVALID_ZERO_BW_PIPE_HANDLE")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	struct 	fid_USBPORT_URB_INVALID_PIPE_REQUEST
	{
		UINT16 fid_URB_Hdr_Length;
		UINT16 fid_URB_Hdr_Function;
		UINT32 fid_URB_Hdr_Status;
		EtlPtr fid_URB_Hdr_UsbdDeviceHandle;
		EtlPtr fid_URB_Hdr_UsbdFlags;
		EtlPtr fid_URB_PipeHandle;
	}
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_NOP_ZERO_BW_PIPE_HANDLE_REQUEST = FormatString("Dispatch URB NOP_ZERO_BW_PIPE_HANDLE_REQUEST")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	struct 	fid_USBPORT_URB_INVALID_PIPE_REQUEST
	{
		UINT16 fid_URB_Hdr_Length;
		UINT16 fid_URB_Hdr_Function;
		UINT32 fid_URB_Hdr_Status;
		EtlPtr fid_URB_Hdr_UsbdDeviceHandle;
		EtlPtr fid_URB_Hdr_UsbdFlags;
		EtlPtr fid_URB_PipeHandle;
	}
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_CONTROL_TRANSFER_ENDPOINT = FormatString("Dispatch URB INVALID_CONTROL_TRANSFER_ENDPOINT")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	CONTROL_TRANSFER_URB_SETUP ControlTransfer;
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_CONTROL_TRANSFER_BUFFER_LENGTH = FormatString("Dispatch URB INVALID_CONTROL_TRANSFER_BUFFER_LENGTH")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	CONTROL_TRANSFER_URB_SETUP ControlTransfer;
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_BULK_OR_INTERRUPT_TRANSFER_ENDPOINT = FormatString("Dispatch URB INVALID_BULK_OR_INTERRUPT_TRANSFER_ENDPOINT")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	URB Urb;
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_BULK_OR_INTERRUPT_TRANSFER_BUFFER_LENGTH = FormatString("Dispatch URB INVALID_BULK_OR_INTERRUPT_TRANSFER_BUFFER_LENGTH")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	URB Urb;
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_ISOCHRONOUS_TRANSFER_ENDPOINT = FormatString("Dispatch URB INVALID_ISOCHRONOUS_TRANSFER_ENDPOINT")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	URB Urb;
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_NULL_TRANSFER_BUFFER_AND_MDL = FormatString("Dispatch URB INVALID_NULL_TRANSFER_BUFFER_AND_MDL")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	struct 	fid_USBPORT_URB_HEADER
	{
		UINT16 fid_URB_Hdr_Length;
		UINT16 fid_URB_Hdr_Function;
		UINT32 fid_URB_Hdr_Status;
		EtlPtr fid_URB_Hdr_UsbdDeviceHandle;
		EtlPtr fid_URB_Hdr_UsbdFlags;
	}
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_NON_NULL_TRANSFER_BUFFER_MDL = FormatString("Dispatch URB INVALID_NON_NULL_TRANSFER_BUFFER_MDL")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	struct 	fid_USBPORT_URB_HEADER
	{
		UINT16 fid_URB_Hdr_Length;
		UINT16 fid_URB_Hdr_Function;
		UINT32 fid_URB_Hdr_Status;
		EtlPtr fid_URB_Hdr_UsbdDeviceHandle;
		EtlPtr fid_URB_Hdr_UsbdFlags;
	}
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_ALLOCATE_MDL_FAILURE = FormatString("Dispatch URB ALLOCATE_MDL_FAILURE")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	struct 	fid_USBPORT_URB_HEADER
	{
		UINT16 fid_URB_Hdr_Length;
		UINT16 fid_URB_Hdr_Function;
		UINT32 fid_URB_Hdr_Status;
		EtlPtr fid_URB_Hdr_UsbdDeviceHandle;
		EtlPtr fid_URB_Hdr_UsbdFlags;
	}
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_ALLOCATE_TRANSFER_CONTEXT_FAILURE = FormatString("Dispatch URB ALLOCATE_TRANSFER_CONTEXT_FAILURE")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	struct 	fid_USBPORT_URB_HEADER
	{
		UINT16 fid_URB_Hdr_Length;
		UINT16 fid_URB_Hdr_Function;
		UINT32 fid_URB_Hdr_Status;
		EtlPtr fid_URB_Hdr_UsbdDeviceHandle;
		EtlPtr fid_URB_Hdr_UsbdFlags;
	}
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_NOP_ROOTHUB_PIPE_HANDLE_REQUEST = FormatString("Dispatch URB NOP_ROOTHUB_PIPE_HANDLE_REQUEST")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	struct 	fid_USBPORT_URB_INVALID_PIPE_REQUEST
	{
		UINT16 fid_URB_Hdr_Length;
		UINT16 fid_URB_Hdr_Function;
		UINT32 fid_URB_Hdr_Status;
		EtlPtr fid_URB_Hdr_UsbdDeviceHandle;
		EtlPtr fid_URB_Hdr_UsbdFlags;
		EtlPtr fid_URB_PipeHandle;
	}
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_ISOCHRONOUS_ZERO_LENGTH = FormatString("Dispatch URB INVALID_ISOCHRONOUS_ZERO_LENGTH")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	URB Urb;
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_ISOCHRONOUS_NUM_PACKETS = FormatString("Dispatch URB INVALID_ISOCHRONOUS_NUM_PACKETS")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	URB Urb;
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_URB_INVALID_ISOCHRONOUS_START_FRAME = FormatString("Dispatch URB INVALID_ISOCHRONOUS_START_FRAME")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	EtlPtr fid_IRP_Ptr;
	UsbUrbPtr fid_URB_Ptr;
	UINT16 fid_USBPORT_URB_NumberOfPackets;
	URB Urb;
	UINT32 fid_URB_FrameNumber;
}
Struct USBPort_USBPORT_ETW_EVENT_IRP_CANCEL = FormatString("Irp Cancel")
{
	USBPort_HostController2 HostController;
	EtlPtr fid_IRP_Ptr;
}
Struct USBPort_USBPORT_ETW_EVENT_USBUSER_OP_RAW_RESET_PORT_DISPATCH = FormatString("USBUSER_OP_RAW_RESET_PORT Dispatch")
{
	USBPort_HostController2 HostController;
	UINT16 fid_PortNumber;
}
Struct USBPort_USBPORT_ETW_EVENT_USBUSER_OP_RAW_RESET_PORT_STATUS1 = FormatString("USBUSER_OP_RAW_RESET_PORT GetPortStatus after SetFeaturePortPower")
{
	USBPort_HostController2 HostController;
	UINT16 fid_PortNumber;
	UINT32 fid_PortStatus;
}
Struct USBPort_USBPORT_ETW_EVENT_USBUSER_OP_RAW_RESET_PORT_STATUS2 = FormatString("USBUSER_OP_RAW_RESET_PORT GetPortStatus after SetFeaturePortReset")
{
	USBPort_HostController2 HostController;
	UINT16 fid_PortNumber;
	UINT32 fid_PortStatus;
}
Struct USBPort_USBPORT_ETW_EVENT_USBUSER_OP_RAW_RESET_PORT_STATUS3 = FormatString("USBUSER_OP_RAW_RESET_PORT GetPortStatus after ClearFeaturePortResetChange")
{
	USBPort_HostController2 HostController;
	UINT16 fid_PortNumber;
	UINT32 fid_PortStatus;
}
Struct USBPort_USBPORT_ETW_EVENT_USBUSER_OP_RAW_RESET_PORT_COMPLETE = FormatString("USBUSER_OP_RAW_RESET_PORT Complete")
{
	USBPort_HostController2 HostController;
	UINT16 fid_PortNumber;
	UINT32 fid_UsbStatus;
}
Struct USBPort_USBPORT_ETW_EVENT_USBUSER_OP_SEND_ONE_PACKET_DISPATCH = FormatString("USBUSER_OP_SEND_ONE_PACKET Dispatch")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Usbuser_Op_Send_One_Packet
	{
		UINT8 fid_DeviceAddress;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_EndpointAddress;
		UINT16 fid_MaximumPacketSize;
		UINT32 fid_Timeout;
		UINT32 fid_UsbPacketFlags;
		UINT32 fid_DataLength;
		UINT16 fid_HubDeviceAddress;
		UINT16 fid_PortTTNumber;
		USBD_STATUS fid_UsbdStatus;
	}
}
Struct USBPort_USBPORT_ETW_EVENT_USBUSER_OP_SEND_ONE_PACKET_DISPATCH_DATA = FormatString("USBUSER_OP_SEND_ONE_PACKET Dispatch with Data")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Usbuser_Op_Send_One_Packet
	{
		UINT8 fid_DeviceAddress;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_EndpointAddress;
		UINT16 fid_MaximumPacketSize;
		UINT32 fid_Timeout;
		UINT32 fid_UsbPacketFlags;
		UINT32 fid_DataLength;
		UINT16 fid_HubDeviceAddress;
		UINT16 fid_PortTTNumber;
		USBD_STATUS fid_UsbdStatus;
	}
	UINT16 fid_PacketDataLength;
	UINT8 fid_PacketData[fid_PacketDataLength];
}
Struct USBPort_USBPORT_ETW_EVENT_USBUSER_OP_SEND_ONE_PACKET_TIMEOUT = FormatString("USBUSER_OP_SEND_ONE_PACKET Timeout")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Usbuser_Op_Send_One_Packet
	{
		UINT8 fid_DeviceAddress;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_EndpointAddress;
		UINT16 fid_MaximumPacketSize;
		UINT32 fid_Timeout;
		UINT32 fid_UsbPacketFlags;
		UINT32 fid_DataLength;
		UINT16 fid_HubDeviceAddress;
		UINT16 fid_PortTTNumber;
		USBD_STATUS fid_UsbdStatus;
	}
}
Struct USBPort_USBPORT_ETW_EVENT_USBUSER_OP_SEND_ONE_PACKET_COMPLETE = FormatString("USBUSER_OP_SEND_ONE_PACKET Complete")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Usbuser_Op_Send_One_Packet
	{
		UINT8 fid_DeviceAddress;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_EndpointAddress;
		UINT16 fid_MaximumPacketSize;
		UINT32 fid_Timeout;
		UINT32 fid_UsbPacketFlags;
		UINT32 fid_DataLength;
		UINT16 fid_HubDeviceAddress;
		UINT16 fid_PortTTNumber;
		USBD_STATUS fid_UsbdStatus;
	}
	UINT32 fid_UsbStatus;
}
Struct USBPort_USBPORT_ETW_EVENT_USBUSER_OP_SEND_ONE_PACKET_COMPLETE_DATA = FormatString("USBUSER_OP_SEND_ONE_PACKET Complete with Data")
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Usbuser_Op_Send_One_Packet
	{
		UINT8 fid_DeviceAddress;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_EndpointAddress;
		UINT16 fid_MaximumPacketSize;
		UINT32 fid_Timeout;
		UINT32 fid_UsbPacketFlags;
		UINT32 fid_DataLength;
		UINT16 fid_HubDeviceAddress;
		UINT16 fid_PortTTNumber;
		USBD_STATUS fid_UsbdStatus;
	}
	UINT16 fid_PacketDataLength;
	UINT8 fid_PacketData[fid_PacketDataLength];
}
Struct USBPort_USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_START_DISPATCH = FormatString("EHCI Miniport Start Dispatch")
{
	USBPort_HostController2 HostController;
}
Struct USBPort_USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_START_COMPLETE = FormatString("EHCI Miniport Start Complete")
{
	USBPort_HostController2 HostController;
	UINT32 fid_MiniportStatus;
}
Struct USBPort_USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_START_COMPLETE_ERROR_1 = FormatString("EHCI Miniport Start Complete Error - Invalid Resources")
{
	USBPort_HostController2 HostController;
	UINT32 fid_MiniportStatus;
}
Struct USBPort_USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_START_COMPLETE_ERROR_2 = FormatString("EHCI Miniport Start Complete Error - Hardware Gone")
{
	USBPort_HostController2 HostController;
	UINT32 fid_MiniportStatus;
}
Struct USBPort_USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_START_COMPLETE_ERROR_3 = FormatString("EHCI Miniport Start Complete Error - Stop BIOS")
{
	USBPort_HostController2 HostController;
	UINT32 fid_MiniportStatus;
}
Struct USBPort_USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_START_COMPLETE_ERROR_4 = FormatString("EHCI Miniport Start Complete Error - Initialize Hardware")
{
	USBPort_HostController2 HostController;
	UINT32 fid_MiniportStatus;
}
Struct USBPort_USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_START_COMPLETE_ERROR_5 = FormatString("EHCI Miniport Start Complete Error - Initialize Schedule")
{
	USBPort_HostController2 HostController;
	UINT32 fid_MiniportStatus;
}
Struct USBPort_USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_STOP_DISPATCH = FormatString("EHCI Miniport Stop Dispatch")
{
	USBPort_HostController2 HostController;
}
Struct USBPort_USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_STOP_COMPLETE = FormatString("EHCI Miniport Stop Complete")
{
	USBPort_HostController2 HostController;
}
Struct USBPort_USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_SUSPEND_DISPATCH = FormatString("EHCI Miniport Suspend Dispatch")
{
	USBPort_HostController2 HostController;
}
Struct USBPort_USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_SUSPEND_COMPLETE = FormatString("EHCI Miniport Suspend Complete")
{
	USBPort_HostController2 HostController;
}
Struct USBPort_USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_RESUME_DISPATCH = FormatString("EHCI Miniport Resume Dispatch")
{
	USBPort_HostController2 HostController;
}
Struct USBPort_USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_RESUME_COMPLETE = FormatString("EHCI Miniport Resume Complete")
{
	USBPort_HostController2 HostController;
	UINT32 fid_MiniportStatus;
	UINT16 fid_NumberOfPorts;
	UINT32 fid_SuspendPortStatus[fid_NumberOfPorts];
	UINT32 fid_ResumePortStatus[fid_NumberOfPorts];
}
Struct USBPort_USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_RESUME_COMPLETE_ERROR_1 = FormatString("EHCI Miniport Resume Complete Error - Hardware Gone")
{
	USBPort_HostController2 HostController;
	UINT32 fid_MiniportStatus;
	UINT16 fid_NumberOfPorts;
	UINT32 fid_SuspendPortStatus[fid_NumberOfPorts];
	UINT32 fid_ResumePortStatus[fid_NumberOfPorts];
}
Struct USBPort_USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_RESUME_COMPLETE_ERROR_2 = FormatString("EHCI Miniport Resume Complete Error - HcHalted")
{
	USBPort_HostController2 HostController;
	UINT32 fid_MiniportStatus;
	UINT16 fid_NumberOfPorts;
	UINT32 fid_SuspendPortStatus[fid_NumberOfPorts];
	UINT32 fid_ResumePortStatus[fid_NumberOfPorts];
}
Struct USBPort_USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_RESUME_COMPLETE_ERROR_3 = FormatString("EHCI Miniport Resume Complete Error - ConfigFlag")
{
	USBPort_HostController2 HostController;
	UINT32 fid_MiniportStatus;
	UINT16 fid_NumberOfPorts;
	UINT32 fid_SuspendPortStatus[fid_NumberOfPorts];
	UINT32 fid_ResumePortStatus[fid_NumberOfPorts];
}
Struct USBPort_USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_RESUME_COMPLETE_ERROR_4 = FormatString("EHCI Miniport Resume Complete Error - PortPower")
{
	USBPort_HostController2 HostController;
	UINT32 fid_MiniportStatus;
	UINT16 fid_NumberOfPorts;
	UINT32 fid_SuspendPortStatus[fid_NumberOfPorts];
	UINT32 fid_ResumePortStatus[fid_NumberOfPorts];
}
Struct USBPort_USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_RESUME_COMPLETE_ERROR_5 = FormatString("EHCI Miniport Resume Complete Error - PortOwnedByCC")
{
	USBPort_HostController2 HostController;
	UINT32 fid_MiniportStatus;
	UINT16 fid_NumberOfPorts;
	UINT32 fid_SuspendPortStatus[fid_NumberOfPorts];
	UINT32 fid_ResumePortStatus[fid_NumberOfPorts];
}
Struct USBPort_USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_RESUME_COMPLETE_ERROR_6 = FormatString("EHCI Miniport Resume Complete Error - OvercurrentChange")
{
	USBPort_HostController2 HostController;
	UINT32 fid_MiniportStatus;
	UINT16 fid_NumberOfPorts;
	UINT32 fid_SuspendPortStatus[fid_NumberOfPorts];
	UINT32 fid_ResumePortStatus[fid_NumberOfPorts];
}
Struct USBPort_USBPORT_ETW_EVENT_HC_EHCI_MINIPORT_DEVICE_DATA = FormatString("EHCI Miniport Device Data")
{
	USBPort_HostController2 HostController;
	UINT32 fid_HcSuspendedFlag;
	UINT32 fid_SuspendHcNotHalted;
	UINT32 fid_HostSystemErrorCount;
	UINT32 fid_HostSystemErrorResetNeeded;
	UINT32 fid_StatAsyncEnableCount;
	UINT32 fid_StatAsyncDisableCount;
	UINT32 fid_StatPeriodicEnableCount;
	UINT32 fid_StatPeriodicDisableCount;
	UINT32 fid_StatAsyncEnableTimeoutCount;
	UINT32 fid_StatAsyncDisableTimeoutCount;
	UINT32 fid_StatPeriodicEnableTimeoutCount;
	UINT32 fid_StatPeriodicDisableTimeoutCount;
	UINT32 fid_StatRingDoorbellDisabledCount;
	UINT32 fid_StatRingDoorbellDisablingCount;
	UINT32 fid_StatRingDoorbellEnablingCount;
	UINT32 fid_StatRingDoorbellEnabledCount;
	UINT32 fid_StatRingDoorbellHwRemovedCount;
	UINT32 fid_StatAnswerDoorbell;
	UINT32 fid_StatAsyncCacheFlushIdle;
	UINT32 fid_StatAsyncCacheFlushNormal;
	UINT32 fid_StatAsyncCacheFlushRetry;
	UINT32 fid_StatIntOnAsyncAdvancePendingCount;
	UINT32 fid_StatIntOnAsyncAdvanceSyncRoutineCount;
	UINT32 fid_StatRingDoorbellEnabledWithRetryCount;
	UINT32 fid_StatRingDoorbellEnabledWithRetryIgnoredCount;
	UINT32 fid_StatAsyncCacheFlushPrevented;
	UINT32 fid_CurrentRingDoorbellDisablingTimerCount;
	UINT32 fid_CurrentRingDoorbellEnablingTimerCount;
	UINT32 fid_CurrentRingDoorbellEnabledTimerCount;
	UINT32 fid_CurrentIntOnAsyncAdvancePendingCount;
	UINT32 fid_StatResetNeededCount;
	UINT32 fid_ResetNeeded;
	UINT32 fid_ResetRecoveryEnable;
	UINT32 fid_ResetRecoveryBreak;
	UINT32 fid_AsyncScheduleState;
	UINT32 fid_AsyncDoorbellState;
	UINT32 fid_PeriodicScheduleState;
	UINT32 fid_EhciInternalFlags;
	UINT8 fid_PreventCmdChangesWithDoorbellPending;
	UINT8 fid_OptimizeInactiveQhFlush;
	UINT8 fid_DisableTwoDoorbellWorkaround;
	UINT8 fid_StrictTransitionChecksEnabled;
	UINT8 fid_IntegratedTTSupportRegistryOverride;
	UINT32 fid_CurrentAsyncEnableCount;
	UINT32 fid_InitialDoorbellRetryEnableValue;
	UINT32 fid_CurrentDoorbellRetryEnableValue;
	UINT32 fid_DoorbellRetryRequired;
	UINT32 fid_PeriodicEnableChangeWithDoorbellPending;
	UINT32 fid_PeriodicDisableChangeWithDoorbellPending;
}
Struct USBPort_USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_START_DISPATCH = FormatString("OHCI Miniport Start Dispatch")
{
	USBPort_HostController2 HostController;
}
Struct USBPort_USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_START_COMPLETE = FormatString("OHCI Miniport Start Complete")
{
	USBPort_HostController2 HostController;
	UINT32 fid_MiniportStatus;
}
Struct USBPort_USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_START_COMPLETE_ERROR_1 = FormatString("OHCI Miniport Start Complete Error - Invalid Resources")
{
	USBPort_HostController2 HostController;
	UINT32 fid_MiniportStatus;
}
Struct USBPort_USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_START_COMPLETE_ERROR_2 = FormatString("OHCI Miniport Start Complete Error - Hardware Gone")
{
	USBPort_HostController2 HostController;
	UINT32 fid_MiniportStatus;
}
Struct USBPort_USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_START_COMPLETE_ERROR_3 = FormatString("OHCI Miniport Start Complete Error - Stop BIOS")
{
	USBPort_HostController2 HostController;
	UINT32 fid_MiniportStatus;
}
Struct USBPort_USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_START_COMPLETE_ERROR_4 = FormatString("OHCI Miniport Start Complete Error - Initialize Schedule")
{
	USBPort_HostController2 HostController;
	UINT32 fid_MiniportStatus;
}
Struct USBPort_USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_START_COMPLETE_ERROR_5 = FormatString("OHCI Miniport Start Complete Error - Initialize Hardware")
{
	USBPort_HostController2 HostController;
	UINT32 fid_MiniportStatus;
}
Struct USBPort_USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_STOP_DISPATCH = FormatString("OHCI Miniport Stop Dispatch")
{
	USBPort_HostController2 HostController;
}
Struct USBPort_USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_STOP_COMPLETE = FormatString("OHCI Miniport Stop Complete")
{
	USBPort_HostController2 HostController;
}
Struct USBPort_USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_SUSPEND_DISPATCH = FormatString("OHCI Miniport Suspend Dispatch")
{
	USBPort_HostController2 HostController;
}
Struct USBPort_USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_SUSPEND_COMPLETE = FormatString("OHCI Miniport Suspend Complete")
{
	USBPort_HostController2 HostController;
}
Struct USBPort_USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_RESUME_DISPATCH = FormatString("OHCI Miniport Resume Dispatch")
{
	USBPort_HostController2 HostController;
}
Struct USBPort_USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_RESUME_COMPLETE = FormatString("OHCI Miniport Resume Complete")
{
	USBPort_HostController2 HostController;
	UINT32 fid_MiniportStatus;
	UINT16 fid_NumberOfPorts;
	UINT32 fid_SuspendPortStatus[fid_NumberOfPorts];
	UINT32 fid_ResumePortStatus[fid_NumberOfPorts];
}
Struct USBPort_USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_RESUME_COMPLETE_ERROR_1 = FormatString("OHCI Miniport Resume Complete Error - Hardware Gone")
{
	USBPort_HostController2 HostController;
	UINT32 fid_MiniportStatus;
	UINT16 fid_NumberOfPorts;
	UINT32 fid_SuspendPortStatus[fid_NumberOfPorts];
	UINT32 fid_ResumePortStatus[fid_NumberOfPorts];
}
Struct USBPort_USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_RESUME_COMPLETE_ERROR_2 = FormatString("OHCI Miniport Resume Complete Error - HcControl")
{
	USBPort_HostController2 HostController;
	UINT32 fid_MiniportStatus;
	UINT16 fid_NumberOfPorts;
	UINT32 fid_SuspendPortStatus[fid_NumberOfPorts];
	UINT32 fid_ResumePortStatus[fid_NumberOfPorts];
}
Struct USBPort_USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_RESUME_COMPLETE_ERROR_3 = FormatString("OHCI Miniport Resume Complete Error - HcHCCA")
{
	USBPort_HostController2 HostController;
	UINT32 fid_MiniportStatus;
	UINT16 fid_NumberOfPorts;
	UINT32 fid_SuspendPortStatus[fid_NumberOfPorts];
	UINT32 fid_ResumePortStatus[fid_NumberOfPorts];
}
Struct USBPort_USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_RESUME_COMPLETE_ERROR_4 = FormatString("OHCI Miniport Resume Complete Error - HcRhS_OverCurrentIndicatorChange")
{
	USBPort_HostController2 HostController;
	UINT32 fid_MiniportStatus;
	UINT16 fid_NumberOfPorts;
	UINT32 fid_SuspendPortStatus[fid_NumberOfPorts];
	UINT32 fid_ResumePortStatus[fid_NumberOfPorts];
}
Struct USBPort_USBPORT_ETW_EVENT_HC_OHCI_MINIPORT_RESUME_COMPLETE_ERROR_5 = FormatString("OHCI Miniport Resume Complete Error - HcRhPS_OverCurrentIndicatorChange")
{
	USBPort_HostController2 HostController;
	UINT32 fid_MiniportStatus;
	UINT16 fid_NumberOfPorts;
	UINT32 fid_SuspendPortStatus[fid_NumberOfPorts];
	UINT32 fid_ResumePortStatus[fid_NumberOfPorts];
}
Struct USBPort_USBPORT_ETW_EVENT_HC_UHCI_MINIPORT_START_DISPATCH = FormatString("UHCI Miniport Start Dispatch")
{
	USBPort_HostController2 HostController;
}
Struct USBPort_USBPORT_ETW_EVENT_HC_UHCI_MINIPORT_START_COMPLETE = FormatString("UHCI Miniport Start Complete")
{
	USBPort_HostController2 HostController;
	UINT32 fid_MiniportStatus;
}
Struct USBPort_USBPORT_ETW_EVENT_HC_UHCI_MINIPORT_START_COMPLETE_ERROR_1 = FormatString("UHCI Miniport Start Complete Error - Invalid Resources")
{
	USBPort_HostController2 HostController;
	UINT32 fid_MiniportStatus;
}
Struct USBPort_USBPORT_ETW_EVENT_HC_UHCI_MINIPORT_START_COMPLETE_ERROR_2 = FormatString("UHCI Miniport Start Complete Error - Stop BIOS")
{
	USBPort_HostController2 HostController;
	UINT32 fid_MiniportStatus;
}
Struct USBPort_USBPORT_ETW_EVENT_HC_UHCI_MINIPORT_START_COMPLETE_ERROR_3 = FormatString("UHCI Miniport Start Complete Error - Initialize Hardware")
{
	USBPort_HostController2 HostController;
	UINT32 fid_MiniportStatus;
}
Struct USBPort_USBPORT_ETW_EVENT_HC_UHCI_MINIPORT_START_COMPLETE_ERROR_4 = FormatString("UHCI Miniport Start Complete Error - Initialize Schedule")
{
	USBPort_HostController2 HostController;
	UINT32 fid_MiniportStatus;
}
Struct USBPort_USBPORT_ETW_EVENT_HC_UHCI_MINIPORT_STOP_DISPATCH = FormatString("UHCI Miniport Stop Dispatch")
{
	USBPort_HostController2 HostController;
}
Struct USBPort_USBPORT_ETW_EVENT_HC_UHCI_MINIPORT_STOP_COMPLETE = FormatString("UHCI Miniport Stop Complete")
{
	USBPort_HostController2 HostController;
}
Struct USBPort_USBPORT_ETW_EVENT_HC_UHCI_MINIPORT_SUSPEND_DISPATCH = FormatString("UHCI Miniport Suspend Dispatch")
{
	USBPort_HostController2 HostController;
}
Struct USBPort_USBPORT_ETW_EVENT_HC_UHCI_MINIPORT_SUSPEND_COMPLETE = FormatString("UHCI Miniport Suspend Complete")
{
	USBPort_HostController2 HostController;
}
Struct USBPort_USBPORT_ETW_EVENT_HC_UHCI_MINIPORT_RESUME_DISPATCH = FormatString("UHCI Miniport Resume Dispatch")
{
	USBPort_HostController2 HostController;
}
Struct USBPort_USBPORT_ETW_EVENT_HC_UHCI_MINIPORT_RESUME_COMPLETE = FormatString("UHCI Miniport Resume Complete")
{
	USBPort_HostController2 HostController;
	UINT32 fid_MiniportStatus;
	UINT16 fid_NumberOfPorts;
	UINT32 fid_SuspendPortStatus[fid_NumberOfPorts];
	UINT32 fid_ResumePortStatus[fid_NumberOfPorts];
}
Struct USBPort_USBPORT_ETW_EVENT_HC_UHCI_MINIPORT_RESUME_COMPLETE_ERROR_1 = FormatString("UHCI Miniport Resume Complete Error - Hardware Gone")
{
	USBPort_HostController2 HostController;
	UINT32 fid_MiniportStatus;
	UINT16 fid_NumberOfPorts;
	UINT32 fid_SuspendPortStatus[fid_NumberOfPorts];
	UINT32 fid_ResumePortStatus[fid_NumberOfPorts];
}
Struct USBPort_USBPORT_ETW_EVENT_HC_UHCI_MINIPORT_RESUME_COMPLETE_ERROR_2 = FormatString("UHCI Miniport Resume Complete Error - EnterGlobalSuspendMode")
{
	USBPort_HostController2 HostController;
	UINT32 fid_MiniportStatus;
	UINT16 fid_NumberOfPorts;
	UINT32 fid_SuspendPortStatus[fid_NumberOfPorts];
	UINT32 fid_ResumePortStatus[fid_NumberOfPorts];
}
Struct USBPort_USBPORT_ETW_EVENT_HC_UHCI_MINIPORT_RESUME_COMPLETE_ERROR_3 = FormatString("UHCI Miniport Resume Complete Error - ForceGlobalResume")
{
	USBPort_HostController2 HostController;
	UINT32 fid_MiniportStatus;
	UINT16 fid_NumberOfPorts;
	UINT32 fid_SuspendPortStatus[fid_NumberOfPorts];
	UINT32 fid_ResumePortStatus[fid_NumberOfPorts];
}
Struct USBPort_USBPORT_ETW_EVENT_HC_UHCI_MINIPORT_RESUME_COMPLETE_ERROR_4 = FormatString("UHCI Miniport Resume Complete Error - FrameNumber")
{
	USBPort_HostController2 HostController;
	UINT32 fid_MiniportStatus;
	UINT16 fid_NumberOfPorts;
	UINT32 fid_SuspendPortStatus[fid_NumberOfPorts];
	UINT32 fid_ResumePortStatus[fid_NumberOfPorts];
}
Struct USBPort_USBPORT_ETW_EVENT_HC_UHCI_MINIPORT_RESUME_COMPLETE_ERROR_5 = FormatString("UHCI Miniport Resume Complete Error - OvercurrentChange")
{
	USBPort_HostController2 HostController;
	UINT32 fid_MiniportStatus;
	UINT16 fid_NumberOfPorts;
	UINT32 fid_SuspendPortStatus[fid_NumberOfPorts];
	UINT32 fid_ResumePortStatus[fid_NumberOfPorts];
}
Struct USBPort_USBPORT_ETW_EVENT_RTPM_TRANSITION = FormatString("Run Time Power Management Transition: %s", RunTimePmEvent(fid_RunTimePmEvent))
{
	USBPort_HostController2 HostController;
	UINT32 fid_RunTimePmEvent = RunTimePmEvent(this);
}
Struct USBPort_USBPORT_ETW_EVENT_DISPATCH_WAIT_WAKE = FormatString("Dispatch IRP_MN_WAIT_WAKE")
{
	USBPort_HostController2 HostController;
	EtlPtr fid_IRP_Ptr;
	UINT32 fid_Status;
}
Struct USBPort_USBPORT_ETW_EVENT_COMPLETE_WAIT_WAKE = FormatString("Complete IRP_MN_WAIT_WAKE")
{
	USBPort_HostController2 HostController;
	EtlPtr fid_IRP_Ptr;
	UINT32 fid_Status;
}
struct USBPort_fid_USBPORT_URB_ISO_PACKETS //Array Struct
{
	UINT32 fid_URB_Packet_Offset;
	UINT32 fid_URB_Packet_Length;
	UINT32 fid_URB_Packet_Status;
}
Struct USBPort_USBPORT_ETW_EVENT_CODE_EXECUTION_TIME = FormatString("%s took %s", fid_CodeTag.ToString, ExecMetrics.ToString)
{
	USBPort_HostController2 HostController;
	USBPort_Execution_Metrics ExecMetrics;
	[Property.USBPerfCodeTag = FormatString("%s", this)]
	UnicodeString fid_CodeTag;
}
Struct USBPort_USBPORT_ETW_EVENT_PUT_SGLIST_EXECUTION_TIME = FormatString("%s took %s", fid_CodeTag.ToString, ExecMetrics.ToString)
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	USBPort_Execution_Metrics ExecMetrics;
	EtlPtr fid_AdapterObject;
	UINT32 fid_NumPutScatterGatherList;
	UINT8  fid_WriteData;
	[Property.USBPerfPutSGFlushLen = FormatString("0x%x", this)]
	UINT32 fid_FlushLength;
	[Property.USBPerfDMACurrentVa = FormatString("%s", this.Ptr.ToString)]
	EtlPtr fid_CurrentVA;
	[Property.USBPerfCodeTag = FormatString("%s", this)]
	UnicodeString fid_CodeTag;
}
Struct USBPort_USBPORT_ETW_EVENT_BUILD_SGLIST_EXECUTION_TIME = FormatString("%s took %s", fid_CodeTag.ToString, ExecMetrics.ToString)
{
	USBPort_HostController2 HostController;
	struct 	fid_USBPORT_Device
	{
		EtlPtr DeviceHandle;
		UINT16 idVendor;
		UINT16 idProduct;
		UsbPortPath PortPath;
		UINT32 DeviceSpeed;
		UINT32 DeviceAddress;
	}
	struct 	fid_USBPORT_Endpoint
	{
		EtlPtr Endpoint;
		EtlPtr PipeHandle;
		EtlPtr DeviceHandle;
	}
	struct 	fid_USBPORT_Endpoint_Descriptor
	{
		UINT8 fid_bLength;
		UINT8 fid_bDescriptorType;
		[Property.USBEndpoint = FormatString("0x%x", this)]
		UINT8 fid_bEndpointAddress;
		UINT8 fid_bmAttributes;
		UINT16 fid_wMaxPacketSize;
		UINT8 fid_bInterval;
	}
	USBPort_Execution_Metrics ExecMetrics;
	EtlPtr fid_AdapterObject;
	UINT32 fid_TransferBufferLength;
	UINT8  fid_WriteData;
	[Property.USBPerfBuildSGLenRemaining = FormatString("0x%x", this)]
	UINT32 fid_LengthRemaining;
	[Property.USBPerfDMACurrentVa = FormatString("%s", this.Ptr.ToString)]
	EtlPtr fid_CurrentVA;
	[Property.USBPerfCodeTag = FormatString("%s", this)]
	UnicodeString fid_CodeTag;
}

[RegisterBefore(EventDescriptor.DefaultKeyword, MicrosoftWindowsUSBUSBPORT_Keyword, "{c88a4ef5-d048-4013-9408-e04b7db2814a}")]
struct USBPort_MicrosoftWindowsUSBUSBPORT_Keyword
{
	UINT64 Diagnostic:1 = FormatString("      (%s) %s", this.ToBitString, this? "USBPORT_ETW_KEYWORD_DIAGNOSTIC":"");
	UINT64 PowerDiagnostics:1 = FormatString("(%s) %s", this.ToBitString, this? "USBPORT_ETW_KEYWORD_POWER_DIAGNOSTICS":"");
	UINT64 PerfDiagnostics:1 = FormatString("(%s) %s", this.ToBitString, this? "USBPORT_ETW_KEYWORD_PERF_DIAGNOSTICS":"");
	UINT64 Reserved1:61 = FormatString("       (%s)", this.ToBitString);
}

struct CONTROL_TRANSFER_URB_SETUP
{
	URB Urb;
	switch (Property.InternalUsbNtstatusUrbs && Property.InternalUsbIsUrbCompletion)
	{
		case 1: [Property.USBNtStatus = this.ToString] NTSTATUS fid_IRP_NtStatus;
	}
}

struct CONTROL_TRANSFER_URB_SETUP_AND_DATA
{
	URB Urb;
	switch (Property.InternalUsbNtstatusUrbs && Property.InternalUsbIsUrbCompletion)
	{
		case 1: [Property.USBNtStatus = this.ToString] NTSTATUS fid_IRP_NtStatus;
	}
	[PostAfter.DataEndOffset = Offset + this]
	UINT16 fid_URB_TransferDataLength;
	struct DataPackets
	{
		switch
		{
			case (USBPort_RequestTypeTypeMap(Urb.SetupPacket.bmRequestType.Type) == "Standard"):
			switch(USBPort_StandardDeviceRequestMap(Urb.SetupPacket.bRequest))
			{
				case "GET_CONFIGURATION": UINT8 Data_ConfigurationValue;
				case "GET_INTERFACE": UINT8 Data_AlternateInterface;
				case "SYNCH_FRAME": UINT16 Data_FrameNumber;
				case "GET_STATUS": switch(USBPort_RequestTypeRecipientMap(Urb.SetupPacket.bmRequestType.Recipient))
				{
					case "Device": UINT16 Data_DeviceStatus
					{
						UINT16 SelfPowered:1 = FormatString("(%s) %d", this.ToBitString, this);
						UINT16 RemoteWakeup:1 = FormatString("(%s) %d", this.ToBitString, this);
						UINT16 Reserved:14;
					}
					case "Endpoint": UINT16 Data_EndpointStatus
					{
						// Halt means the endpoint will return STALL
						UINT16 Halt:1 = FormatString("(%s) %d", this.ToBitString, this);
						UINT16 Reserved:15;
					}
					default: BLOB (DataEndOffset - Offset) Data_Status;
				}
				case "GET_DESCRIPTOR":
				case "SET_DESCRIPTOR":
					USB_DESCRIPTORS Descriptor;
				case "SET_SEL": Struct
				{
					UINT8 U1SEL;
					UINT8 U1PEL;
					UINT16 U2SEL;
					UINT16 U2PEL;
				}
				default: BLOB (DataEndOffset - Offset) _Data;
			}
			case !IsValueNone(Urb.SetupPacket.Index_Port):
				// Could be Get Port Status request to a USB hub
				// TODO: USB3 port status is shown incorrectly as 2.0--can't distinguish here yet
				Usb2PortStatus Usb2PortStatus;
			default: BLOB (DataEndOffset - Offset) Data;
		}
	}
}

struct SETUP_PACKET = USBPort_RequestTypeTypeMap(bmRequestType.Type) == "Standard" ?
							FormatString("%s", USBPort_StandardDeviceRequestMap(bRequest)) :
							!IsValueNone(Index_Port) ?
								// Could be Get Port Status request to a USB hub
								FormatString("Get Port Status (%d)", Index_Port) :
							""
{
	UINT8 bmRequestType = FormatString("(%s request) 0x%x", USBPort_RequestTypeTypeMap(this.Type), this)
	{
		UINT8 Recipient:5 = FormatString("(%s) %s", this.ToBitString, USBPort_RequestTypeRecipientMap(this));
		UINT8 Type:2 = FormatString("     (%s) %s", this.ToBitString, USBPort_RequestTypeTypeMap(this));
		UINT8 Direction:1 = FormatString("(%s) %s", this.ToBitString, USBPort_RequestTypeDirectionMap(this));
	};
	UINT8 bRequest =
		USBPort_RequestTypeTypeMap(bmRequestType.Type) == "Standard" ?
		FormatString("(%d) %s", this, USBPort_StandardDeviceRequestMap(this)) :
		FormatString("0x%x", this) ;
	// wValue:
	switch
	{
		case (USBPort_RequestTypeTypeMap(bmRequestType.Type) == "Standard"):
		switch (USBPort_StandardDeviceRequestMap(bRequest))
		{
			case "GET_DESCRIPTOR":
			case "SET_DESCRIPTOR": struct
			{
				UINT8 Value_DescriptorIndex;
				UINT8 Value_DescriptorType =
					FormatString("(%d) %s", this, UsbDescriptorTypeTable(this));
			}
			case "CLEAR_FEATURE":
			case "SET_FEATURE": switch(USBPort_RequestTypeRecipientMap(bmRequestType.Recipient))
			{
				case "Device": UINT16 Value_DeviceFeature =
					FormatString("(%d) %s", this, USBPort_DeviceFeatureMap(this));
				case "Interface": UINT16 Value_InterfaceFeature =
					FormatString("(%d) Unknown interface feature", this);
				case "Endpoint": UINT16 Value_EndpointFeature =
					FormatString("(%d) %s", this, USBPort_EndpointFeatureMap(this));
				default: UINT16 Value_UnknownFeature;
			}
			case "SET_ADDRESS": UINT16 Value_DeviceAddress;
			case "SET_CONFIGURATION": struct
			{
				UINT8 Value_ConfigurationValue;
				UINT8 Value_Reserved;
			}
			case "SET_INTERFACE": UINT16 Value_AlternateSetting;
			default: UINT16 _wValue;
		}
		default: UINT16 wValue;
	}
	// wIndex:
	switch
	{
		case (USBPort_RequestTypeTypeMap(bmRequestType.Type) == "Standard"):
		switch
		{
			case (USBPort_RequestTypeRecipientMap(bmRequestType.recipient) == "Device" &&
				(USBPort_StandardDeviceRequestMap(bRequest) == "GET_DESCRIPTOR" ||
				USBPort_StandardDeviceRequestMap(bRequest) == "SET_DESCRIPTOR") &&
				UsbDescriptorTypeTable(Value_DescriptorType) == "STRING"): UINT16 Index_Language;
			case (USBPort_RequestTypeRecipientMap(bmRequestType.recipient) == "Interface"): UINT16 Index_Interface;
			case (USBPort_RequestTypeRecipientMap(bmRequestType.recipient) == "Endpoint"): UINT16 Index_Endpoint;
			default: UINT16 _wIndex;
		}
		case (USBPort_RequestTypeTypeMap(bmRequestType.Type) == "Class" &&
			USBPort_RequestTypeRecipientMap(bmRequestType.Recipient) == "Other" &&
			USBPort_RequestTypeDirectionMap(bmRequestType.Direction) == "Device-to-host" &&
			USBPort_StandardDeviceRequestMap(bRequest) == "GET_STATUS"):
			// Could be Get Port Status request to a USB hub
			UINT16 Index_Port;
		default: UINT16 wIndex;
	}
	UINT16 wLength;
}

Struct Usb2PortStatus = FormatString("[%s] %s", wPortStatus.ToString, wPortChange.ToString)
{
	UINT16 wPortStatus = FormatString("%s%s%s%s%s%s%s%s%s%s",
		PORT_CONNECTION   == 1 ? "c" : "",
		PORT_ENABLE       == 1 ? "e" : "",
		PORT_SUSPEND      == 1 ? "s" : "",
		PORT_OVER_CURRENT == 1 ? "o" : "",
		PORT_RESET        == 1 ? "r" : "",
		PORT_POWER        == 1 ? "p" : "",
		PORT_LOW_SPEED    == 1 ? "l" : "",
		PORT_HIGH_SPEED   == 1 ? "h" : "",
		PORT_TEST         == 1 ? "t" : "",
		PORT_INDICATOR    == 1 ? "i" : ""
		)
	{
		UINT16 PORT_CONNECTION:1 = FormatString("  (%s) %s", this.ToBitString, "PORT_CONNECTION");
		UINT16 PORT_ENABLE:1 = FormatString("      (%s) %s", this.ToBitString, "PORT_ENABLE");
		UINT16 PORT_SUSPEND:1 = FormatString("     (%s) %s", this.ToBitString, "PORT_SUSPEND");
		UINT16 PORT_OVER_CURRENT:1 = FormatString("(%s) %s", this.ToBitString, "PORT_OVER_CURRENT");
		UINT16 PORT_RESET:1 = FormatString("       (%s) %s", this.ToBitString, "PORT_RESET");
		UINT16 Reserved:3;
		UINT16 PORT_POWER:1 = FormatString("       (%s) %s", this.ToBitString, "PORT_POWER");
		UINT16 PORT_LOW_SPEED:1 = FormatString("   (%s) %s", this.ToBitString, "PORT_LOW_SPEED");
		UINT16 PORT_HIGH_SPEED:1 = FormatString("  (%s) %s", this.ToBitString, "PORT_HIGH_SPEED");
		UINT16 PORT_TEST:1 = FormatString("        (%s) %s", this.ToBitString, "PORT_TEST");
		UINT16 PORT_INDICATOR:1 = FormatString("   (%s) %s", this.ToBitString, "PORT_INDICATOR");
		UINT16 Reserved2:3;
	}
	UINT16 wPortChange = USBPort_ChangeBitsStringMap(this)
	{
		[Property.USBIsConnect = (this == 1 && wPortStatus.PORT_CONNECTION == 1) ? 1 : 0]
		[Property.USBIsDisconnect = (this == 1 && wPortStatus.PORT_CONNECTION == 0) ? 1 : 0]
		UINT16 C_PORT_CONNECTION:1 = FormatString("  (%s) %s", this.ToBitString, "C_PORT_CONNECTION");
		UINT16 C_PORT_ENABLE:1 = FormatString("      (%s) %s", this.ToBitString, "C_PORT_ENABLE");
		UINT16 C_PORT_SUSPEND:1 = FormatString("     (%s) %s", this.ToBitString, "C_PORT_SUSPEND");
		UINT16 C_PORT_OVER_CURRENT:1 = FormatString("(%s) %s", this.ToBitString, "C_PORT_OVER_CURRENT");
		UINT16 C_PORT_RESET:1 = FormatString("       (%s) %s", this.ToBitString, "C_PORT_RESET");
		UINT16 Reserved:11;
	}
}

// bmRequestType.Recipient
Table USBPort_RequestTypeRecipientMap(value)
{
	switch(value)
	{
		case 0: "Device";
		case 1: "Interface";
		case 2: "Endpoint";
		case 3: "Other";
		default: "Reserved";
	}
}

// bmRequestType.Type
Table USBPort_RequestTypeTypeMap(value)
{
	switch(value)
	{
		case 0: "Standard";
		case 1: "Class";
		case 2: "Vendor";
		case 3: "Reserved";
	}
}

// bmRequestType.Dir
Table USBPort_RequestTypeDirectionMap(value)
{
	switch(value)
	{
		case 0: "Host-to-device";
		case 1: "Device-to-host";
	}
}

Table USBPort_StandardDeviceRequestMap(value)
{
	switch(value)
	{
		case 0: "GET_STATUS";
		case 1: "CLEAR_FEATURE";
		case 2: "Reserved for future use";
		case 3: "SET_FEATURE";
		case 4: "Reserved for future use";
		case 5: "SET_ADDRESS";
		case 6: "GET_DESCRIPTOR";
		case 7: "SET_DESCRIPTOR";
		case 8: "GET_CONFIGURATION";
		case 9: "SET_CONFIGURATION";
		case 10: "GET_INTERFACE";
		case 11: "SET_INTERFACE";
		case 12: "SYNCH_FRAME";
		case 48: "SET_SEL";
		case 49: "SET_ISOCH_DELAY";
		default: "Unknown";
	}
}

Table UsbDescriptorTypeTable(value)
{
	switch(value)
	{
		case 1: "DEVICE";
		case 2: "CONFIGURATION";
		case 3: "STRING";
		case 4: "INTERFACE";
		case 5: "ENDPOINT";
		case 6: "DEVICE_QUALIFIER";
		case 7: "OTHER_SPEED_CONFIGURATION";
		case 8: "INTERFACE_POWER";
		case 9: "OTG";
		case 10: "DEBUG";
		case 11: "INTERFACE_ASSOCIATION";
		case 15: "BOS";
		case 16: "DEVICE_CAPABILITY";
		case 48: "SUPERSPEED_ENDPOINT_COMPANION";
		default: "Unknown";
	}
}

Table USBPort_DeviceFeatureMap(value)
{
	switch(value)
	{
		case 1: "DEVICE_REMOTE_WAKEUP";
		case 2: "TEST_MODE";
		case 48: "U1_ENABLE";
		case 49: "U2_ENABLE";
		case 50: "LTM_ENABLE";
		default: "Unknown device feature";
	}
}

Table USBPort_EndpointFeatureMap(value)
{
	switch(value)
	{
		case 0: "ENDPOINT_HALT";
		default: "Unknown endpoint feature";
	}
}

//
// Descriptions for common values of hub port status change bits. Show bit string for multiple
// changes.
//
Table USBPort_ChangeBitsStringMap(value)
{
	switch(value)
	{
		case 0x0: "0";
		case 0x1: "Changed PORT_CONNECTION";
		case 0x2: "Changed PORT_ENABLE";
		case 0x4: "Changed PORT_SUSPEND";
		case 0x8: "Changed PORT_OVER_CURRENT";
		case 0x10: "Changed PORT_RESET";
		default: value.ToBitString;
	}
}

Table UsbSpeedTable(value)
{
	switch(value)
	{
	case 0: "UsbLowSpeed";
	case 1: "UsbFullSpeed";
	case 2: "UsbHighSpeed";
	case 3: "UsbSuperSpeed";
	}
}

Table UsbDeviceCapabilityTypeTable(value)
{
	switch(value)
	{
	case 1: "Wireless_USB";
	case 2: "USB 2.0 EXTENSION";
	case 3: "SUPERSPEED_USB";
	case 4: "CONTAINER_ID";
	default: "Unknown";
	}
}

Table UsbdStatusTable(value)
{
	switch(value)
	{
		// usb.h 2014/09/25
		case 0x00000000: "success";                          // USBD_STATUS_SUCCESS
		case 0x00000001: "port_operation_pending";           // USBD_STATUS_PORT_OPERATION_PENDING
		case 0x40000000: "pending";                          // USBD_STATUS_PENDING
		case 0xC0000001: "crc";                              // USBD_STATUS_CRC
		case 0xC0000002: "btstuff";                          // USBD_STATUS_BTSTUFF
		case 0xC0000003: "data_toggle_mismatch";             // USBD_STATUS_DATA_TOGGLE_MISMATCH
		case 0xC0000004: "stall_pid";                        // USBD_STATUS_STALL_PID
		case 0xC0000005: "dev_not_responding";               // USBD_STATUS_DEV_NOT_RESPONDING
		case 0xC0000006: "pid_check_failure";                // USBD_STATUS_PID_CHECK_FAILURE
		case 0xC0000007: "unexpected_pid";                   // USBD_STATUS_UNEXPECTED_PID
		case 0xC0000008: "data_overrun";                     // USBD_STATUS_DATA_OVERRUN
		case 0xC0000009: "data_underrun";                    // USBD_STATUS_DATA_UNDERRUN
		case 0xC000000A: "reserved1";                        // USBD_STATUS_RESERVED1
		case 0xC000000B: "reserved2";                        // USBD_STATUS_RESERVED2
		case 0xC000000C: "buffer_overrun";                   // USBD_STATUS_BUFFER_OVERRUN
		case 0xC000000D: "buffer_underrun";                  // USBD_STATUS_BUFFER_UNDERRUN
		case 0xC000000F: "not_accessed";                     // USBD_STATUS_NOT_ACCESSED
		case 0xC0000010: "fifo";                             // USBD_STATUS_FIFO
		case 0xC0000011: "xact_error";                       // USBD_STATUS_XACT_ERROR
		case 0xC0000012: "babble_detected";                  // USBD_STATUS_BABBLE_DETECTED
		case 0xC0000013: "data_buffer_error";                // USBD_STATUS_DATA_BUFFER_ERROR
		case 0xC0000014: "no_ping_response";                 // USBD_STATUS_NO_PING_RESPONSE
		case 0xC0000015: "invalid_stream_type";              // USBD_STATUS_INVALID_STREAM_TYPE
		case 0xC0000016: "invalid_stream_id";                // USBD_STATUS_INVALID_STREAM_ID
		case 0xC0000030: "endpoint_halted";                  // USBD_STATUS_ENDPOINT_HALTED
		case 0x80000200: "invalid_urb_function";             // USBD_STATUS_INVALID_URB_FUNCTION
		case 0x80000300: "invalid_parameter";                // USBD_STATUS_INVALID_PARAMETER
		case 0x80000400: "error_busy";                       // USBD_STATUS_ERROR_BUSY
		case 0x80000600: "invalid_pipe_handle";              // USBD_STATUS_INVALID_PIPE_HANDLE
		case 0x80000700: "no_bandwidth";                     // USBD_STATUS_NO_BANDWIDTH
		case 0x80000800: "internal_hc_error";                // USBD_STATUS_INTERNAL_HC_ERROR
		case 0x80000900: "error_short_transfer";             // USBD_STATUS_ERROR_SHORT_TRANSFER
		case 0xC0000A00: "bad_start_frame";                  // USBD_STATUS_BAD_START_FRAME
		case 0xC0000B00: "isoch_request_failed";             // USBD_STATUS_ISOCH_REQUEST_FAILED
		case 0xC0000C00: "frame_control_owned";              // USBD_STATUS_FRAME_CONTROL_OWNED
		case 0xC0000D00: "frame_control_not_owned";          // USBD_STATUS_FRAME_CONTROL_NOT_OWNED
		case 0xC0000E00: "not_supported";                    // USBD_STATUS_NOT_SUPPORTED
		case 0xC0000F00: "inavlid_configuration_descriptor"; // USBD_STATUS_INAVLID_CONFIGURATION_DESCRIPTOR
		case 0xC0001000: "insufficient_resources";           // USBD_STATUS_INSUFFICIENT_RESOURCES
		case 0xC0002000: "set_config_failed";                // USBD_STATUS_SET_CONFIG_FAILED
		case 0xC0003000: "buffer_too_small";                 // USBD_STATUS_BUFFER_TOO_SMALL
		case 0xC0004000: "interface_not_found";              // USBD_STATUS_INTERFACE_NOT_FOUND
		case 0xC0005000: "inavlid_pipe_flags";               // USBD_STATUS_INAVLID_PIPE_FLAGS
		case 0xC0006000: "timeout";                          // USBD_STATUS_TIMEOUT
		case 0xC0007000: "device_gone";                      // USBD_STATUS_DEVICE_GONE
		case 0xC0008000: "status_not_mapped";                // USBD_STATUS_STATUS_NOT_MAPPED
		case 0xC0009000: "hub_internal_error";               // USBD_STATUS_HUB_INTERNAL_ERROR
		case 0xC0010000: "canceled";                         // USBD_STATUS_CANCELED
		case 0xC0020000: "iso_not_accessed_by_hw";           // USBD_STATUS_ISO_NOT_ACCESSED_BY_HW
		case 0xC0030000: "iso_td_error";                     // USBD_STATUS_ISO_TD_ERROR
		case 0xC0040000: "iso_na_late_usbport";              // USBD_STATUS_ISO_NA_LATE_USBPORT
		case 0xC0050000: "iso_not_accessed_late";            // USBD_STATUS_ISO_NOT_ACCESSED_LATE
		case 0xC0100000: "bad_descriptor";                   // USBD_STATUS_BAD_DESCRIPTOR
		case 0xC0100001: "bad_descriptor_blen";              // USBD_STATUS_BAD_DESCRIPTOR_BLEN
		case 0xC0100002: "bad_descriptor_type";              // USBD_STATUS_BAD_DESCRIPTOR_TYPE
		case 0xC0100003: "bad_interface_descriptor";         // USBD_STATUS_BAD_INTERFACE_DESCRIPTOR
		case 0xC0100004: "bad_endpoint_descriptor";          // USBD_STATUS_BAD_ENDPOINT_DESCRIPTOR
		case 0xC0100005: "bad_interface_assoc_descriptor";   // USBD_STATUS_BAD_INTERFACE_ASSOC_DESCRIPTOR
		case 0xC0100006: "bad_config_desc_length";           // USBD_STATUS_BAD_CONFIG_DESC_LENGTH
		case 0xC0100007: "bad_number_of_interfaces";         // USBD_STATUS_BAD_NUMBER_OF_INTERFACES
		case 0xC0100008: "bad_number_of_endpoints";          // USBD_STATUS_BAD_NUMBER_OF_ENDPOINTS
		case 0xC0100009: "bad_endpoint_address";             // USBD_STATUS_BAD_ENDPOINT_ADDRESS
		default: "Unknown";
	}
}

// User-mode IOCTLs
Table UsbIoctlTable(value)
{
	switch (value)
	{
		case 0x2203fc: "IOCTL_USB_HCD_GET_STATS_1";
		case 0x220400: "IOCTL_USB_DIAGNOSTIC_MODE_ON";
		case 0x220404: "IOCTL_USB_DIAGNOSTIC_MODE_OFF";
		// Same value has different meaning to hub driver vs. controller driver
		case 0x220408: "IOCTL_USB_GET_NODE_INFORMATION or IOCTL_USB_GET_ROOT_HUB_NAME (check recipient)";
		case 0x22040c: "IOCTL_USB_GET_NODE_CONNECTION_INFORMATION";
		case 0x220410: "IOCTL_USB_GET_DESCRIPTOR_FROM_NODE_CONNECTION";
		case 0x220414: "IOCTL_USB_GET_NODE_CONNECTION_NAME";
		case 0x220418: "IOCTL_USB_DIAG_IGNORE_HUBS_ON";
		case 0x22041c: "IOCTL_USB_DIAG_IGNORE_HUBS_OFF";
		case 0x220420: "IOCTL_USB_GET_NODE_CONNECTION_DRIVERKEY_NAME";
		case 0x220424: "IOCTL_GET_HCD_DRIVERKEY_NAME";
		case 0x220428: "IOCTL_USB_HCD_GET_STATS_2";
		case 0x220430: "IOCTL_USB_HCD_DISABLE_PORT";
		case 0x220434: "IOCTL_USB_HCD_ENABLE_PORT";
		case 0x220438: "IOCTL_USB_USER_REQUEST";
		case 0x22043c: "IOCTL_USB_GET_HUB_CAPABILITIES";
		case 0x220440: "IOCTL_USB_GET_NODE_CONNECTION_ATTRIBUTES";
		case 0x220444: "IOCTL_USB_HUB_CYCLE_PORT";
		case 0x220448: "IOCTL_USB_GET_NODE_CONNECTION_INFORMATION_EX";
		case 0x22044c: "IOCTL_USB_RESET_HUB";
		case 0x220450: "IOCTL_USB_GET_HUB_CAPABILITIES_EX";
		case 0x220454: "IOCTL_USB_GET_HUB_INFORMATION_EX";
		case 0x220458: "IOCTL_USB_GET_PORT_CONNECTOR_PROPERTIES";
		case 0x22045c: "IOCTL_USB_GET_NODE_CONNECTION_INFORMATION_EX_V2";
		default: FormatString("Unknown USB UM IOCTL 0x%x", value);
	}
}

// Kernel-mode IOCTLs
Table UsbIoctlInternalTable(value)
{
	switch (value)
	{
		case 0x220003: "IOCTL_INTERNAL_USB_SUBMIT_URB";
		case 0x220007: "IOCTL_INTERNAL_USB_RESET_PORT";
		case 0x22000f: "IOCTL_INTERNAL_USB_GET_ROOTHUB_PDO";
		case 0x220013: "IOCTL_INTERNAL_USB_GET_PORT_STATUS";
		case 0x220017: "IOCTL_INTERNAL_USB_ENABLE_PORT";
		case 0x22001b: "IOCTL_INTERNAL_USB_GET_HUB_COUNT";
		case 0x22001f: "IOCTL_INTERNAL_USB_CYCLE_PORT";
		case 0x220020: "IOCTL_INTERNAL_USB_GET_HUB_NAME";
		case 0x220027: "IOCTL_INTERNAL_USB_SUBMIT_IDLE_NOTIFICATION";
		case 0x22002b: "IOCTL_INTERNAL_USB_RECORD_FAILURE";
		case 0x220420: "IOCTL_INTERNAL_USB_GET_BUS_INFO";
		case 0x220424: "IOCTL_INTERNAL_USB_GET_CONTROLLER_NAME";
		case 0x220428: "IOCTL_INTERNAL_USB_GET_BUSGUID_INFO";
		case 0x22042c: "IOCTL_INTERNAL_USB_GET_PARENT_HUB_INFO";
		case 0x220433: "IOCTL_INTERNAL_USB_GET_DEVICE_HANDLE";
		case 0x220437: "IOCTL_INTERNAL_USB_GET_DEVICE_HANDLE_EX";
		case 0x22043b: "IOCTL_INTERNAL_USB_GET_TT_DEVICE_HANDLE";
		case 0x22043f: "IOCTL_INTERNAL_USB_GET_TOPOLOGY_ADDRESS";
		case 0x220443: "IOCTL_INTERNAL_USB_NOTIFY_IDLE_READY";
		case 0x220447: "IOCTL_INTERNAL_USB_REQ_GLOBAL_SUSPEND";
		case 0x22044b: "IOCTL_INTERNAL_USB_REQ_GLOBAL_RESUME";
		case 0x22044f: "IOCTL_INTERNAL_USB_GET_DEVICE_CONFIG_INFO";
		case 0x490003: "IOCTL_INTERNAL_USB_REGISTER_COMPOSITE_DEVICE";
		case 0x490007: "IOCTL_INTERNAL_USB_UNREGISTER_COMPOSITE_DEVICE";
		case 0x49000b: "IOCTL_INTERNAL_USB_REQUEST_REMOTE_WAKE_NOTIFICATION";
		case 0x49104b: "(private) IOCTL_INTERNAL_USB_QUERY_USB_CAPABILITY";
		case 0x49103f: "(private) IOCTL_INTERNAL_USB_ENDPOINT_RESET";
		case 0x49100b: "(private) IOCTL_INTERNAL_USB_ROOTHUB_GET_INFO";
		case 0x49100f: "(private) IOCTL_INTERNAL_USB_ROOTHUB_GET_20PORT_INFO";
		case 0x491013: "(private) IOCTL_INTERNAL_USB_ROOTHUB_GET_30PORT_INFO";
		case 0x491007: "(private) IOCTL_INTERNAL_USB_ADDRESS0_OWNERSHIP_ACQUIRE";
		case 0x491017: "(private) IOCTL_INTERNAL_USB_USBDEVICE_ENABLE";
		case 0x49101b: "(private) IOCTL_INTERNAL_USB_USBDEVICE_RESET";
		case 0x49101f: "(private) IOCTL_INTERNAL_USB_USBDEVICE_ADDRESS";
		case 0x491023: "(private) IOCTL_INTERNAL_USB_USBDEVICE_UPDATE";
		case 0x491027: "(private) IOCTL_INTERNAL_USB_USBDEVICE_HUB_INFO";
		case 0x49102b: "(private) IOCTL_INTERNAL_USB_USBDEVICE_DISABLE";
		case 0x49102f: "(private) IOCTL_INTERNAL_USB_USBDEVICE_PURGEIO";
		case 0x491033: "(private) IOCTL_INTERNAL_USB_USBDEVICE_STARTIO";
		case 0x491037: "(private) IOCTL_INTERNAL_USB_ENDPOINTS_CONFIGURE";
		case 0x49103b: "(private) IOCTL_INTERNAL_USB_DEFAULT_ENDPOINT_UPDATE";
		case 0x491043: "(private) IOCTL_INTERNAL_USB_GET_HUB_INFO";
		case 0x491053: "(private) IOCTL_INTERNAL_USB_USBDEVICE_TREE_PURGEIO";
		case 0x491404: "(private) IOCTL_INTERNAL_USB_GET_DUMP_DATA";
		case 0x491408: "(private) IOCTL_INTERNAL_USB_FREE_DUMP_DATA";
		case 0x49140f: "(private) IOCTL_INTERNAL_USB_NOTIFY_FORWARD_PROGRESS";
		case 0x220fa3: "(private) IOCTL_INTERNAL_USB_PROPAGATE_RESUME";
		case 0x220fa7: "(private) IOCTL_INTERNAL_USB_NOTIFY_HUB_PWR_LOSS";
		case 0x220fb3: "(private) IOCTL_INTERNAL_USB_RESET_PORT_ASYNC";
		case 0x220fab: "(private) IOCTL_INTERNAL_USB_RESET_NOTIFICATION_REQUEST";
		case 0x49104f: "(private) IOCTL_INTERNAL_USB_SET_FUNCTION_HANDLE_DATA";
		case 0x220010: "(private) IOCTL_USB_GET_PORT_STATUS";
		default: FormatString("Unknown USB KM IOCTL 0x%x", value);
	}
}

Table USBPort_UsbUrbFunction(Function)
{
	switch(Function)
	{
		case 0x0000: "URB_FUNCTION_SELECT_CONFIGURATION";
		case 0x0001: "URB_FUNCTION_SELECT_INTERFACE";
		case 0x0002: "URB_FUNCTION_ABORT_PIPE";
		case 0x0003: "URB_FUNCTION_TAKE_FRAME_LENGTH_CONTROL";
		case 0x0004: "URB_FUNCTION_RELEASE_FRAME_LENGTH_CONTROL";
		case 0x0005: "URB_FUNCTION_GET_FRAME_LENGTH";
		case 0x0006: "URB_FUNCTION_SET_FRAME_LENGTH";
		case 0x0007: "URB_FUNCTION_GET_CURRENT_FRAME_NUMBER";
		case 0x0008: "URB_FUNCTION_CONTROL_TRANSFER";
		case 0x0009: "URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER";
		case 0x000A: "URB_FUNCTION_ISOCH_TRANSFER";
		case 0x000B: "URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE";
		case 0x000C: "URB_FUNCTION_SET_DESCRIPTOR_TO_DEVICE";
		case 0x000D: "URB_FUNCTION_SET_FEATURE_TO_DEVICE";
		case 0x000E: "URB_FUNCTION_SET_FEATURE_TO_INTERFACE";
		case 0x000F: "URB_FUNCTION_SET_FEATURE_TO_ENDPOINT";
		case 0x0010: "URB_FUNCTION_CLEAR_FEATURE_TO_DEVICE";
		case 0x0011: "URB_FUNCTION_CLEAR_FEATURE_TO_INTERFACE";
		case 0x0012: "URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT";
		case 0x0013: "URB_FUNCTION_GET_STATUS_FROM_DEVICE";
		case 0x0014: "URB_FUNCTION_GET_STATUS_FROM_INTERFACE";
		case 0x0015: "URB_FUNCTION_GET_STATUS_FROM_ENDPOINT";
		case 0x0016: "URB_FUNCTION_RESERVED_0X0016";
		case 0x0017: "URB_FUNCTION_VENDOR_DEVICE";
		case 0x0018: "URB_FUNCTION_VENDOR_INTERFACE";
		case 0x0019: "URB_FUNCTION_VENDOR_ENDPOINT";
		case 0x001A: "URB_FUNCTION_CLASS_DEVICE";
		case 0x001B: "URB_FUNCTION_CLASS_INTERFACE";
		case 0x001C: "URB_FUNCTION_CLASS_ENDPOINT";
		case 0x001D: "URB_FUNCTION_RESERVE_0X001D";
		case 0x001E: "URB_FUNCTION_SYNC_RESET_PIPE_AND_CLEAR_STALL";
		case 0x001F: "URB_FUNCTION_CLASS_OTHER";
		case 0x0020: "URB_FUNCTION_VENDOR_OTHER";
		case 0x0021: "URB_FUNCTION_GET_STATUS_FROM_OTHER";
		case 0x0022: "URB_FUNCTION_CLEAR_FEATURE_TO_OTHER";
		case 0x0023: "URB_FUNCTION_SET_FEATURE_TO_OTHER";
		case 0x0024: "URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT";
		case 0x0025: "URB_FUNCTION_SET_DESCRIPTOR_TO_ENDPOINT";
		case 0x0026: "URB_FUNCTION_GET_CONFIGURATION";
		case 0x0027: "URB_FUNCTION_GET_INTERFACE";
		case 0x0028: "URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE";
		case 0x0029: "URB_FUNCTION_SET_DESCRIPTOR_TO_INTERFACE";
		case 0x002A: "URB_FUNCTION_GET_MS_FEATURE_DESCRIPTOR";
		case 0x0030: "URB_FUNCTION_SYNC_RESET_PIPE";
		case 0x0031: "URB_FUNCTION_SYNC_CLEAR_STALL";
		case 0x0032: "URB_FUNCTION_CONTROL_TRANSFER_EX";
		case 0x0035: "URB_FUNCTION_OPEN_STATIC_STREAMS";
		case 0x0036: "URB_FUNCTION_CLOSE_STATIC_STREAMS";
		case 0x0037: "URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER_USING_CHAINED_MDL";
		case 0x0038: "URB_FUNCTION_ISOCH_TRANSFER_USING_CHAINED_MDL";
		default: "Unknown";
	}
}

[Global.InternalUsbTblVid$[Property.USBDevicePtr] = FormatString("0x%04X", idVendor)]
[Global.InternalUsbTblPid$[Property.USBDevicePtr] = FormatString("0x%04X", idProduct)]
struct USB_DEVICE_DESCRIPTOR = FormatString("VID_%04X&PID_%04X", idVendor, idProduct)
{
	UINT8 bLength;
	UINT8 bDescriptorType;
	UINT16 bcdUSB;
	UINT8 bDeviceClass;
	UINT8 bDeviceSubClass;
	UINT8 bDeviceProtocol;
	UINT8 bMaxPacketSize0;
	UINT16 idVendor;
	UINT16 idProduct;
	UINT16 bcdDevice;
	UINT8 iManufacturer;
	UINT8 iProduct;
	UINT8 iSerialNumber;
	UINT8 bNumConfigurations;
}

struct USB_ENDPOINT_DESCRIPTOR = FormatString("bmAttrubibutes 0x%x", bmAttributes)
{
	UINT8 bLength;
	UINT8 bDescriptorType;
	UINT8 bEndpointAddress;
	UINT8 bmAttributes;
	UINT16 wMaxPacketSize;
	UINT8 bInterval;
}

struct USB_SUPERSPEED_ENDPOINT_COMPANION_DESCRIPTOR = FormatString("MaxBurst %d", bMaxBurst)
{
	UINT8 bLength;
	UINT8 bDescriptorType;
	UINT8 bMaxBurst;
	UINT8 MaxStreamsOrMult; // max streams (5 bits) for bulk, or mult (2 bits) for isoch. this is bmAttributes
	UINT16 wBytesPerInterval;
}

struct USB_CONFIGURATION_DESCRIPTOR = FormatString("Value %d Length %d", bConfigurationValue, wTotalLength)
{
	UINT8 bLength;
	UINT8 bDescriptorType;
	UINT16 wTotalLength;
	UINT8 bNumInterfaces;
	UINT8 bConfigurationValue;
	UINT8 iConfiguration;
	UINT8 bmAttributes;
	UINT8 bMaxPower;
}

//
// Save the interface data for the first interface descriptor for each device. This descriptor
// tells us the whole device's class.
//
[Global.InternalUsbTblClass$[Property.USBDevicePtr] =
	IsValueNone(Global.InternalUsbTblClass$[Property.USBDevicePtr]) ?
	FormatString("0x%X", bInterfaceClass) :
	Global.InternalUsbTblClass$[Property.USBDevicePtr] ]
[Global.InternalUsbTblSubclass$[Property.USBDevicePtr] =
	IsValueNone(Global.InternalUsbTblSubclass$[Property.USBDevicePtr]) ?
	FormatString("0x%X", bInterfaceSubClass) :
	Global.InternalUsbTblSubclass$[Property.USBDevicePtr] ]
[Global.InternalUsbTblProtocol$[Property.USBDevicePtr] =
	IsValueNone(Global.InternalUsbTblProtocol$[Property.USBDevicePtr]) ?
	FormatString("0x%X", bInterfaceProtocol) :
	Global.InternalUsbTblProtocol$[Property.USBDevicePtr] ]
struct USB_INTERFACE_DESCRIPTOR = FormatString("Interface %d alt %d", bInterfaceNumber, bAlternateSetting)
{
	UINT8 bLength;
	UINT8 bDescriptorType;
	UINT8 bInterfaceNumber;
	UINT8 bAlternateSetting;
	UINT8 bNumEndpoints;
	UINT8 bInterfaceClass;
	UINT8 bInterfaceSubClass;
	UINT8 bInterfaceProtocol;
	UINT8 iInterface;
}

struct USB_STRING_DESCRIPTOR = bString
{
	UINT8 bLength;
	UINT8 bDescriptorType;
	UnicodeString((bLength-2)/2) bString;
}

struct USB_BOS_DESCRIPTOR = FormatString ("%d descriptors", bNumDeviceCaps)
{
	UINT8 bLength;
	UINT8 bDescriptorType;
	UINT16 wTotalLength;
	UINT8 bNumDeviceCaps;
}

struct USB_DEVICE_CAPABILITY_DESCRIPTOR = Local.CapabilityDescription
{
	[Local.StartOffset = Offset]
	UINT8 bLength;
	UINT8 bDescriptorType;
	UINT8 bDevCapabilityType = FormatString("(%d) %s", this, UsbDeviceCapabilityTypeTable(this));
	switch (UsbDeviceCapabilityTypeTable(bDevCapabilityType))
	{
	case "USB 2.0 EXTENSION":
		[Post.Local.CapabilityDescription = this.ToString]
		UINT32 bmAttributes_Usb2 = FormatString("%s", (LPM ? "LPM" : "No LPM"))
		{
			UINT32 Reserved_1:1;
			UINT32 LPM:1;
			UINT32 Reserved_2:30;
		}
	case "SUPERSPEED_USB": Struct
		{
			UINT8 bmAttributes_Ss = FormatString("%s", (LTM ? "LTM" : "No LTM"))
			{
				UINT8 Reserved_1:1;
				UINT8 LTM:1;
				UINT8 Reserved_2:6;
			};
			UINT16 wSpeedsSupported = FormatString("%s%s%s%s",
				LowSpeed   ? "ls " : "",
				FullSpeed  ? "fs " : "",
				HighSpeed  ? "hs " : "",
				SuperSpeed ? "ss " : ""
				)
			{
				UINT16 LowSpeed:1;
				UINT16 FullSpeed:1;
				UINT16 HighSpeed:1;
				UINT16 SuperSpeed:1;
				UINT16 Reserved:12;
			}
			UINT8 bFunctionalitySupport = UsbSpeedTable(this);
			UINT8 bU1DevExitLat;
			[Post.Local.CapabilityDescription = FormatString("Speeds: %s", wSpeedsSupported.ToString)]
			UINT16 wU2DevExitLat;
		}
	case "CONTAINER_ID": Struct
		{
			UINT8 bReserved;
			[Post.Local.CapabilityDescription = this.ToString]
			GUID(false) ContainerID; // TODO: should marshalled be true or false?
		}

	default:
		[Post.Local.CapabilityDescription = "Unknown capability"]
		BLOB(bLength - (Offset - Local.StartOffset)) UnknownCapability;
	}
}

struct USBPort_HostController2 = HostController.ToString
{
	EtlPtr DeviceObject;
	USBPort_HostController HostController;
}

struct USBPort_Execution_Metrics = FormatString("%I64d s", Delta)
{
	[Property.USBPerfStartTime = FormatString("%I64d", this)]
	UINT64 StartTime;
	[Property.USBPerfStopTime = FormatString("%I64d", this)]
	UINT64 StopTime;
	[Property.USBPerfDelta = FormatString("%I64d", this)]
	UINT64 Delta;
}

struct USBPort_HostController = FormatString("PCI\\VEN_%04X&DEV_%04X, bus %d, device %d, function %d", PciVendorId, PciDeviceId, PciBus, PciDevice, PciFunction)
{
	UINT32 PciBus;
	UINT16 PciDevice;
	UINT16 PciFunction;
	UINT16 PciVendorId;
	UINT16 PciDeviceId;
}

[Global.InternalUsbTblPortPath$[Property.USBDevicePtr] = this.ToString]
struct UsbPortPath = (PortPathDepth == 0 ? "-" :
                   PortPathDepth == 1 ? FormatString("%d", PortPath0) :
                   PortPathDepth == 2 ? FormatString("%d,%d", PortPath0, PortPath1) :
                   PortPathDepth == 3 ? FormatString("%d,%d,%d", PortPath0, PortPath1, PortPath2) :
                   PortPathDepth == 4 ? FormatString("%d,%d,%d,%d", PortPath0, PortPath1, PortPath2, PortPath3) :
                   PortPathDepth == 5 ? FormatString("%d,%d,%d,%d,%d", PortPath0, PortPath1, PortPath2, PortPath3, PortPath4) :
                   PortPathDepth == 6 ? FormatString("%d,%d,%d,%d,%d,%d", PortPath0, PortPath1, PortPath2, PortPath3, PortPath4, PortPath5) :
                   "invalid")
{
	UINT32 PortPathDepth;
	UINT32 PortPath0;
	UINT32 PortPath1;
	UINT32 PortPath2;
	UINT32 PortPath3;
	UINT32 PortPath4;
	UINT32 PortPath5;
}

// TODO: Improve this structure to dump more information about Power / Pnp / Ioctls
struct IO_STACK_LOCATION = FormatString("IoStackLocation")
{
   [Property.MajorFunction] 
   UINT8 MajorFunction;
   [Property.MinorFunction] 
   UINT8 MinorFunction;
   UINT8 Flags;
   UINT8 Control;
   EtlPtr Arg1;
   EtlPtr Arg2;
   [Property.IoControlCode = (MajorFunction == IRP_MJ_INTERNAL_DEVICE_CONTROL || MajorFunction == IRP_MJ_DEVICE_CONTROL) ? this.Ptr : ""]
   EtlPtr Arg3;
   EtlPtr Arg4;
   EtlPtr DeviceObject
   EtlPtr FileObject
   EtlPtr CompletionRoutine 
   EtlPtr Context
}

// TODO: Merge IRP_X86 and IRP_X64 structures into 1. 
struct IRP_X86 = FormatString("IRP")
{
	UINT16 Type
	UINT16 Size
	EtlPtr MdlAddress
	UINT32 Flags
	EtlPtr AssociatedIrp
	EtlPtr ThreadListEntry_Flink
	EtlPtr ThreadListEntry_Blink
	NTSTATUS IoStatus_Status
	UINT32   IoStatus_Information
	UINT8  RequestorMode
	UINT8 PendingReturned
	UINT8  StackCount
	UINT8 CurrentLocation
	UINT8 Cancel
	UINT8 CancelIrql
	UINT8 ApcEnvironment
	UINT8 AllocationFlags
	EtlPtr UserIosb
	EtlPtr UserEvent
	BLOB(8) Overlay
	EtlPtr CancelRoutine
	EtlPtr UserBuffer
	BLOB(16) Tail_OverLay_DriverContext
	EtlPtr   Tail_OverLay_Thread
	EtlPtr   Tail_Overlay_AuxilaryBuffer
	EtlPtr   Tail_Overlay_ListEntry_Flink
	EtlPtr   Tail_Overlay_ListEntry_Blink
	EtlPtr   Tail_Overlay_CurrentSTackLocation
	BLOB(12) Remaining
}

struct IRP_X64 = FormatString("IRP")
{
	UINT16 Type
	UINT16 Size
	BLOB(4) Pad0
	EtlPtr MdlAddress
	UINT32 Flags
	BLOB(4) Pad1
	EtlPtr AssociatedIrp
	EtlPtr ThreadListEntry_Flink
	EtlPtr ThreadListEntry_Blink
	NTSTATUS IoStatus_Status
	UINT32   IoStatus_Pad1
	UINT32   IoStatus_Information
	UINT32   IoStatus_Pad2
	UINT8  RequestorMode
	UINT8 PendingReturned
	UINT8  StackCount
	UINT8 CurrentLocation
	UINT8 Cancel
	UINT8 CancelIrql
	UINT8 ApcEnvironment
	UINT8 AllocationFlags
	EtlPtr UserIosb
	EtlPtr UserEvent
	BLOB(16) Overlay
	EtlPtr CancelRoutine
	EtlPtr UserBuffer
	BLOB(32) Tail_OverLay_DriverContext
	EtlPtr   Tail_OverLay_Thread
	EtlPtr   Tail_Overlay_AuxilaryBuffer
	EtlPtr   Tail_Overlay_ListEntry_Flink
	EtlPtr   Tail_Overlay_ListEntry_Blink
	EtlPtr   Tail_Overlay_CurrentSTackLocation
	BLOB(16) Remaining
}

// Doesn't cover all URBs, but covers the beginning of most transfer URBs.
struct URB = FormatString("%sFunction = %s, Length = %s, Flags 0x%x",
							Property.USBDStatus != "" ? Property.USBDStatus + ", " : "",
							USBPort_UsbUrbFunction(fid_URB_Hdr_Function),
							Property.USBLength,
							fid_URB_TransferFlags
							)
{
	UINT16 fid_URB_Hdr_Length;
	UINT16 fid_URB_Hdr_Function = FormatString("%s (0x%x)", USBPort_UsbUrbFunction(this), this);
	// Only show status for completion urb events, not dispatch urb events
	switch(Property.InternalUsbIsUrbCompletion)
	{
	case 1:
		USBD_STATUS fid_URB_Hdr_Status;
	default:
		UINT32      fid_URB_Hdr_Status_ignored;
	}
	EtlPtr fid_URB_Hdr_UsbdDeviceHandle;
	EtlPtr fid_URB_Hdr_UsbdFlags;
	
	Struct
	{
		switch(fid_URB_Hdr_Function) 
		{
		
		case 0x0000: // URB_FUNCTION_SELECT_CONFIGURATION
		Struct
		{
			EtlPtr fid_ConfigurationDescriptor;
			EtlPtr fid_ConfigurationHandle;
		}
		
		//
		// Following are all the transfer URBs
		//
		case 0x0008: //URB_FUNCTION_CONTROL_TRANSFER
		case 0x0009: //URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER
		case 0x000A: //URB_FUNCTION_ISOCH_TRANSFER
		case 0x000B: //URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE
		case 0x000C: //URB_FUNCTION_SET_DESCRIPTOR_TO_DEVICE
		case 0x000D: //URB_FUNCTION_SET_FEATURE_TO_DEVICE
		case 0x000E: //URB_FUNCTION_SET_FEATURE_TO_INTERFACE
		case 0x000F: //URB_FUNCTION_SET_FEATURE_TO_ENDPOINT
		case 0x0010: //URB_FUNCTION_CLEAR_FEATURE_TO_DEVICE
		case 0x0011: //URB_FUNCTION_CLEAR_FEATURE_TO_INTERFACE
		case 0x0012: //URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT
		case 0x0013: //URB_FUNCTION_GET_STATUS_FROM_DEVICE
		case 0x0014: //URB_FUNCTION_GET_STATUS_FROM_INTERFACE
		case 0x0015: //URB_FUNCTION_GET_STATUS_FROM_ENDPOINT
		case 0x0017: //URB_FUNCTION_VENDOR_DEVICE
		case 0x0018: //URB_FUNCTION_VENDOR_INTERFACE
		case 0x0019: //URB_FUNCTION_VENDOR_ENDPOINT
		case 0x001A: //URB_FUNCTION_CLASS_DEVICE
		case 0x001B: //URB_FUNCTION_CLASS_INTERFACE
		case 0x001C: //URB_FUNCTION_CLASS_ENDPOINT
		case 0x001F: //URB_FUNCTION_CLASS_OTHER
		case 0x0020: //URB_FUNCTION_VENDOR_OTHER
		case 0x0021: //URB_FUNCTION_GET_STATUS_FROM_OTHER
		case 0x0022: //URB_FUNCTION_CLEAR_FEATURE_TO_OTHER
		case 0x0023: //URB_FUNCTION_SET_FEATURE_TO_OTHER
		case 0x0024: //URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT
		case 0x0025: //URB_FUNCTION_SET_DESCRIPTOR_TO_ENDPOINT
		case 0x0026: //URB_FUNCTION_GET_CONFIGURATION
		case 0x0027: //URB_FUNCTION_GET_INTERFACE
		case 0x0028: //URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE
		case 0x0029: //URB_FUNCTION_SET_DESCRIPTOR_TO_INTERFACE
		case 0x002A: //URB_FUNCTION_GET_MS_FEATURE_DESCRIPTOR
		case 0x0032: //URB_FUNCTION_CONTROL_TRANSFER_EX
		case 0x0037: //URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER_USING_CHAINED_MDL
		case 0x0038: //URB_FUNCTION_ISOCH_TRANSFER_USING_CHAINED_MDL
		Struct {
			UsbPipeHandle fid_URB_PipeHandle;
			UINT32 fid_URB_TransferFlags = Property.USBDirection +
						(this.USBD_SHORT_TRANSFER_OK ? ", short ok" : "") +
						(this.USBD_START_ISO_TRANSFER_ASAP ? ", iso asap" : "") +
						(this.USBD_DEFAULT_PIPE_TRANSFER ? ", default pipe" : "") +
						FormatString(" (0x%x)", this)
			{
				[Property.USBDirection = (this ? "In" : "Out")]
				UINT32 USBD_TRANSFER_DIRECTION_IN:1 = FormatString("  (%s) %d", this.ToBitString, this);
				UINT32 USBD_SHORT_TRANSFER_OK:1 = FormatString("      (%s) %d", this.ToBitString, this);
				UINT32 USBD_START_ISO_TRANSFER_ASAP:1 = FormatString("(%s) %d", this.ToBitString, this);
				UINT32 USBD_DEFAULT_PIPE_TRANSFER:1 = FormatString("  (%s) %d", this.ToBitString, this);
				UINT32 Reserved:12;
			}
			//
			// URB length
			//
			switch(Property.InternalUsbIsUrbCompletion)
			{
			case 1:
				[Property.USBLengthCompleted]
				//
				// On completion, we must save the most recent requested length in an unchanging global
				// in order for it to stick around and not get overwritten (all properties that
				// reference it would get overwritten too). Make up a unique table index, save to it,
				// and then use it.
				//
				[Property.InternalUsbUniqueUrbIndex = FormatString("%s_%d", Property.InternalUsbUrbPtr, FrameNumber)]
				[Global.InternalUsbTblUrbLength$[Property.InternalUsbUniqueUrbIndex] = Global.InternalUsbTblLengthRequested$[Property.InternalUsbUrbPtr]]
				[Property.USBLengthRequested = Global.InternalUsbTblUrbLength$[Property.InternalUsbUniqueUrbIndex]]
				[Property.USBLength = FormatString("%d of %d", this, Property.USBLengthRequested)]
				//
				// Do the same table save for URB completion time. Must convert to seconds from
				// 100-nanosecond units.
				//
				[Global.InternalUsbTblUrbRequestDuration$[Property.InternalUsbUniqueUrbIndex] =
					TimeOffset - Global.InternalUsbTblUrbDispatchTime$[Property.InternalUsbUrbPtr]]
				[Property.USBRequestDuration = Global.InternalUsbTblUrbRequestDuration$[Property.InternalUsbUniqueUrbIndex] / (1000*1000*10.0)]
				UINT32 TransferBufferLength_Completed;
			default:
				[Global.InternalUsbTblLengthRequested$[Property.InternalUsbUrbPtr] = this]
				[Global.InternalUsbTblUrbDispatchTime$[Property.InternalUsbUrbPtr] = TimeOffset]
				[Property.USBLength = FormatString("%d", this)]
				[Property.USBLengthRequested]
				UINT32 TransferBufferLength_Requested;
			}
			EtlPtr TransferBuffer;
			EtlPtr TransferBufferMDL;
			EtlPtr UrbLink;
			EtlPtr Hca[8];
			switch(fid_URB_Hdr_Function)			
			{
				case 0x9: //URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER
				case 0x37: //URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER_USING_CHAINED_MDL
				Struct
				{
					// No Addition information for Bulk/Interrupt Transfers
				}
				
				case 0x0038: //URB_FUNCTION_ISOCH_TRANSFER_USING_CHAINED_MDL
				case 0x000A: //URB_FUNCTION_ISOCH_TRANSFER
				Struct
				{
					[Property.USBIsochStartFrame]
					UINT32 fid_URB_StartFrame;
					[Property.USBIsochNumPackets]
					UINT32 fid_URB_NumberOfPackets;
					UINT32 fid_URB_ErrorCount;
					USBPort_fid_USBPORT_URB_ISO_PACKETS fid_USBPORT_URB_ISO_PACKETS[fid_URB_NumberOfPackets];
				}
				
				//
				// Remaining all are Control Transfers with a SetupPacket
				//
				default:
					SETUP_PACKET SetupPacket;
			}
		}
		
		// 
		// Following are all the Pipe Transfers
		//
		case 0x0002: //URB_FUNCTION_ABORT_PIPE
		case 0x001E: //URB_FUNCTION_SYNC_RESET_PIPE_AND_CLEAR_STALL
		case 0x0030: //URB_FUNCTION_SYNC_RESET_PIPE
		case 0x0031: //URB_FUNCTION_SYNC_CLEAR_STALL		
		case 0x0036: //URB_FUNCTION_CLOSE_STATIC_STREAMS
		Struct
		{
			UsbPipeHandle fid_URB_PipeHandle;
			UINT32        Reserved;	
		}
		
		//
		// TODO: Parsing code for the following URBs needs to be added.
		//
		case 0x0001: //URB_FUNCTION_SELECT_INTERFACE
		case 0x0003: //URB_FUNCTION_TAKE_FRAME_LENGTH_CONTROL
		case 0x0004: //URB_FUNCTION_RELEASE_FRAME_LENGTH_CONTROL
		case 0x0005: //URB_FUNCTION_GET_FRAME_LENGTH
		case 0x0006: //URB_FUNCTION_SET_FRAME_LENGTH
		case 0x0007: //URB_FUNCTION_GET_CURRENT_FRAME_NUMBER
		case 0x0035: //URB_FUNCTION_OPEN_STATIC_STREAMS
		Struct
		{
		
		}
			
		default:
		//
		// An URB that is unexpected here. We would need to update the Parser file
		// if we see this field.
		//
		EtlPtr Unknown;
		
		}
	}
}

Struct UsbUrbPtr = Pointer.Ptr.ToString
{
	[Property.InternalUsbUrbPtr = Pointer.Ptr]
	EtlPtr Pointer;
}

// Parameter: Property.InternalUsbDescriptorLength
// Set this parameter before using this struct, else it will consume the rest of the frame
Struct USB_DESCRIPTORS
{
	[Local.StartOffset = Offset]
	while Descriptors[Offset < (IsValueNone(Property.InternalUsbDescriptorLength) ?
	                            DataEndOffset :
	                            Property.InternalUsbDescriptorLength + Local.StartOffset)]
	{
		// All descriptors start with first byte = length, second byte = descriptor type
		// Look ahead at descriptor length
		switch(UINT8(FrameData, Offset))
		{
		case 0:
		case 1:
			// Length should have been >= 2
			BLOB (1) InvalidLength;
		default:
			// Look ahead at descriptor type
			switch(UsbDescriptorTypeTable(UINT8(FrameData, Offset+1)))
			{
				case "DEVICE":            USB_DEVICE_DESCRIPTOR            DeviceDescriptor;
				case "CONFIGURATION":     USB_CONFIGURATION_DESCRIPTOR     ConfigurationDescriptor;
				case "STRING":            USB_STRING_DESCRIPTOR            StringDescriptor;
				case "INTERFACE":         USB_INTERFACE_DESCRIPTOR         InterfaceDescriptor;
				case "ENDPOINT":          USB_ENDPOINT_DESCRIPTOR          EndpointDescriptor;
				case "SUPERSPEED_ENDPOINT_COMPANION":
				                          USB_SUPERSPEED_ENDPOINT_COMPANION_DESCRIPTOR
				                                                           EndpointCompanionDescriptor;
				case "BOS":               USB_BOS_DESCRIPTOR               BosDescriptor;
				case "DEVICE_CAPABILITY": USB_DEVICE_CAPABILITY_DESCRIPTOR CapabilityDescriptor;
				// Get length again (first byte of descriptor) and mark that many
				// bytes as an unparsed blob
				default: BLOB (UINT8(FrameData, Offset)) Descriptor;
			}
		}
	}
}

[Property.USBDStatus = UsbdStatusTable(Status)]
Struct USBD_STATUS = Status.ToString
{
	UINT32 Status = FormatString("%s (0x%x)", UsbdStatusTable(this), this);
}

// Some events have endpoint pointer, some have pipe handle, some have both
// The same properties are set on both of them

Struct UsbEndpointPtr = Pointer.Ptr.ToString
{
	[Property.USBEndpointPtr = Pointer.Ptr]
	// Get all endpoint attributes from global tables into event properties
	[Global.InternalUsbTblFrameNumberToUSBEndpoint$[FrameNumber] = Global.InternalUsbTblEndpoint$[Pointer.Ptr]]
	[Post.Property.USBEndpoint = Global.InternalUsbTblFrameNumberToUSBEndpoint$[FrameNumber]]
	EtlPtr Pointer;
}

// TODO: This can probably be reduced to a simple property once USB3 URB events have EndpointPtr. Also move UsbEndpointPtr to etl_usb3.npl and delete references to USBPipeHandle in that file.
Struct UsbPipeHandle = Pointer.Ptr.ToString
{
	[Property.USBPipeHandle = Pointer.Ptr]
	// Get all endpoint attributes from global tables into event properties
	// Don't overwrite USBEndpoint (address) if it's already been found
	[Global.InternalUsbTblFrameNumberToUSBEndpoint$[FrameNumber] = !IsValueNone(Global.InternalUsbTblFrameNumberToUSBEndpoint$[FrameNumber]) ? Global.InternalUsbTblFrameNumberToUSBEndpoint$[FrameNumber] : Global.InternalUsbTblEndpoint$[Pointer.Ptr]]
	[Post.Property.USBEndpoint = !IsValueNone(Property.USBEndpoint) ? Property.USBEndpoint : Global.InternalUsbTblFrameNumberToUSBEndpoint$[FrameNumber]]
	EtlPtr Pointer;
}
